{
    "messages": [
        [
            {
                "role": "user",
                "content": "Create job shop scheduling model with 6 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total weighted flowtime. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Job two and four will have task durations in minutes. Other jobs will have task durations in seconds."
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 6  \nnumber_of_machines = 6  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\nweight_choices = [1, 2, 4]\nprobabilities = [0.2, 0.6, 0.2]\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    durations = []\n    for i in range(number_of_jobs):\n        if(i==1 or i==3):\n            durations.append([random.randint(1, maximum_duration)*60 for _ in  range(number_of_machines)]) \n        else:\n            durations.append([random.randint(1, maximum_duration) for _ in  range(number_of_machines)])\n        \n    return durations\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\ndef get_weights(weight_choices, probabilities, number_of_jobs):\n    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\nweights = get_weights(weight_choices, probabilities, number_of_jobs)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n\n    # Objective\n    m.minimize(sum(weights*(end[:, number_of_tasks -1] - release_times)))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Total Weighted Flowtime:\", sum(weights*(end[:, number_of_machines-1].value() - release_times)))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 5 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total flow time (completion time - release time). Maximum duration is 20. Note: The first task related to each job shoub be completed before the completion of any job."
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 5  \nnumber_of_machines = 6  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\nweight_choices = [1, 2, 4]\nprobabilities = [0.2, 0.6, 0.2]\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\ndef get_weights(weight_choices, probabilities, number_of_jobs):\n    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\nweights = get_weights(weight_choices, probabilities, number_of_jobs)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n        \n    # The first task related to each job shoub be completed before the completion of any job\n    for i in range(number_of_jobs):\n        m += (end[:, 0] <= end[i, 5])\n\n    # Objective\n    m.minimize(sum(end[:, number_of_tasks -1] - release_times))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Total Flowtime:\", sum(end[:, number_of_machines-1].value() - release_times))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 7 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total flow time (completion time - release time). Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Sixth task of Job five should be the last task to complete"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 7  \nnumber_of_machines = 6  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\nweight_choices = [1, 2, 4]\nprobabilities = [0.2, 0.6, 0.2]\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\ndef get_weights(weight_choices, probabilities, number_of_jobs):\n    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\nweights = get_weights(weight_choices, probabilities, number_of_jobs)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n        \n    # Sixth task of Job five should be the last task to complete\n    for i in range(number_of_jobs):\n        if i != 4:\n            m += (end[i, 5] <= start[4, 5])\n\n    # Objective\n    m.minimize(sum(end[:, number_of_tasks -1] - release_times))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Total Flowtime:\", sum(end[:, number_of_machines-1].value() - release_times))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 5 jobs and 5 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. The objective function is maximum tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Fifth task of Job five should be the last task to complete"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 5  \nnumber_of_machines = 5  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n        \n    # Fifth task of Job five should be the last task to complete\n    for i in range(number_of_jobs):\n        if i != 4:\n            m += (end[i, 4] <= start[4, 4])\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n\n    # Objective\n    m.minimize(max(tardiness))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Max Tardiness:\", max(tardiness.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 6 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total weighted flowtime. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Sixth task of Job five should be the last task to complete"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 6  \nnumber_of_machines = 6  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\nweight_choices = [1, 2, 4]\nprobabilities = [0.2, 0.6, 0.2]\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\ndef get_weights(weight_choices, probabilities, number_of_jobs):\n    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\nweights = get_weights(weight_choices, probabilities, number_of_jobs)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n        \n    # Sixth task of Job five should be the last task to complete\n    for i in range(number_of_jobs):\n        if i != 4:\n            m += (end[i, 5] <= start[4, 5])\n\n    # Objective\n    m.minimize(sum(weights*(end[:, number_of_tasks -1] - release_times)))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Total Weighted Flowtime:\", sum(weights*(end[:, number_of_machines-1].value() - release_times)))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 5 jobs and 5 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. The objective function is maximum tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Fifth task of Job five should be the last task to complete"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 5  \nnumber_of_machines = 5  \nmaximum_duration = 20\ndue_date_allowance = 1.3\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    \n    # model\n    m = Model()\n    \n    # constraints\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n        \n     # Fifth task of Job five should be the last task to complete\n    for i in range(number_of_jobs):\n        if i != 4:\n            m += (end[i, 4] <= start[4, 4])\n\n    # Objective\n    m.minimize(max(tardiness))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Max Tardiness:\", max(tardiness.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 6 jobs and 5 machines. All jobs have random routes and their operations have random durations. The objective function is makespan. Maximum duration is 26. After solving the problem, solutions will be printed and visualised. Note: Job two has to be completed first"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 6  \nnumber_of_machines = 5  \nmaximum_duration = 26\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    \n    # model\n    m = Model()\n    \n    # constraints\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # Job two has to be completed first\n    for i in range(number_of_jobs):\n        if i != 1:\n            m += (end[i, 4] > end[1, 4])\n\n    # Objective\n    m.minimize(max(end))\n\n    return m, (start, end)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end)) = model(jobs, last_time, durations, task_to_machine_mapping)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Makespan:\", max(end.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 4 jobs and 4 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total weighted flowtime. Maximum duration is 20. After solving the problem, solutions will be printed and visualised."
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 4  \nnumber_of_machines = 4  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\nweight_choices = [1, 2, 4]\nprobabilities = [0.2, 0.6, 0.2]\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\ndef get_weights(weight_choices, probabilities, number_of_jobs):\n    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\nweights = get_weights(weight_choices, probabilities, number_of_jobs)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n\n    # Objective\n    m.minimize(sum(weights*(end[:, number_of_tasks -1] - release_times)))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Total Weighted Flowtime:\", sum(weights*(end[:, number_of_machines-1].value() - release_times)))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 6 jobs and 6 machines. All jobs have random routes and their operations have random durations. The objective function is makespan. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Job two and four will have task durations in minutes. Other jobs will have task durations in seconds"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 6  \nnumber_of_machines = 6  \nmaximum_duration = 20\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    durations = []\n    for i in range(number_of_jobs):\n        if(i==1 or i==3):\n            durations.append([random.randint(1, maximum_duration)*60 for _ in  range(number_of_machines)]) \n        else:\n            durations.append([random.randint(1, maximum_duration) for _ in  range(number_of_machines)])\n        \n    return durations\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    \n    # model\n    m = Model()\n    \n    # constraints\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n\n    # Objective\n    m.minimize(max(end))\n\n    return m, (start, end)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end)) = model(jobs, last_time, durations, task_to_machine_mapping)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Makespan:\", max(end.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 6 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. The objective function is maximum tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Job two and four will have task durations in minutes. Other jobs will have task durations in seconds"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 6  \nnumber_of_machines = 6  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    durations = []\n    for i in range(number_of_jobs):\n        if(i==1 or i==3):\n            durations.append([random.randint(1, maximum_duration)*60 for _ in  range(number_of_machines)]) \n        else:\n            durations.append([random.randint(1, maximum_duration) for _ in  range(number_of_machines)])\n        \n    return durations\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n\n    # Objective\n    m.minimize(max(tardiness))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Max Tardiness:\", max(tardiness.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 4 jobs and 4 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. The objective function is maximum tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised."
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 4  \nnumber_of_machines = 4  \nmaximum_duration = 20\ndue_date_allowance = 1.3\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    \n    # model\n    m = Model()\n    \n    # constraints\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n\n    # Objective\n    m.minimize(max(tardiness))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Max Tardiness:\", max(tardiness.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 5 jobs and 5 machines. All jobs have random routes and their operations have random durations. The objective function is makespan. Maximum duration is 25. After solving the problem, solutions will be printed and visualised. Note: Second task of Job two has to come before all the second tasks of other jobs"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 5  \nnumber_of_machines = 5  \nmaximum_duration = 25\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    \n    # model\n    m = Model()\n    \n    # constraints\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # The 2nd task of job 2 has to come before all 2nd tasks of other jobs\n    for i in range(number_of_jobs):\n        if i != 1:\n            m += (start[i, 1] >= start[1, 1])\n\n    # Objective\n    m.minimize(max(end))\n\n    return m, (start, end)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end)) = model(jobs, last_time, durations, task_to_machine_mapping)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Makespan:\", max(end.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 5 jobs and 5 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. The objective function is maximum tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised.Note: Job two has to be completed first"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 5  \nnumber_of_machines = 5  \nmaximum_duration = 20\ndue_date_allowance = 1.3\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    \n    # model\n    m = Model()\n    \n    # constraints\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n        \n    # Job two has to be completed first\n    for i in range(number_of_jobs):\n        if i != 1:\n            m += (end[i, 4] > end[1, 4]) \n\n    # Objective\n    m.minimize(max(tardiness))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Max Tardiness:\", max(tardiness.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 6 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total weighted tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: The first task related to each job shoub be completed before the completion of any job."
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 6  \nnumber_of_machines = 6  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\nweight_choices = [1, 2, 4]\nprobabilities = [0.2, 0.6, 0.2]\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\ndef get_weights(weight_choices, probabilities, number_of_jobs):\n    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\nweights = get_weights(weight_choices, probabilities, number_of_jobs)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n        \n    # The first task related to each job shoub be completed before the completion of any job\n    for i in range(number_of_jobs):\n        m += (end[:, 0] <= end[i, 5])\n\n    # Objective\n    m.minimize(sum(weights*tardiness))\n\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Total Weighted Tardiness:\", sum(weights*tardiness.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 6 jobs and 5 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. The objective function is maximum tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Fifth task of Job five should be the last task to complete"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 6  \nnumber_of_machines = 5  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n        \n    # Fifth task of Job five should be the last task to complete\n    for i in range(number_of_jobs):\n        if i != 4:\n            m += (end[i, 4] <= start[4, 4])\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n\n    # Objective\n    m.minimize(max(tardiness))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Max Tardiness:\", max(tardiness.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 6 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total flow time (completion time - release time). Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Job two has to be completed first"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 6  \nnumber_of_machines = 6  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\nweight_choices = [1, 2, 4]\nprobabilities = [0.2, 0.6, 0.2]\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\ndef get_weights(weight_choices, probabilities, number_of_jobs):\n    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\nweights = get_weights(weight_choices, probabilities, number_of_jobs)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n        \n    # Job two has to be completed first\n    for i in range(number_of_jobs):\n        if i != 1:\n            m += (end[i, 5] > end[1, 5])\n\n    # Objective\n    m.minimize(sum(end[:, number_of_tasks -1] - release_times))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Total Flowtime:\", sum(end[:, number_of_machines-1].value() - release_times))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 5 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total weighted flowtime. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Job two has to be completed first."
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 5  \nnumber_of_machines = 6  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\nweight_choices = [1, 2, 4]\nprobabilities = [0.2, 0.6, 0.2]\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\ndef get_weights(weight_choices, probabilities, number_of_jobs):\n    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\nweights = get_weights(weight_choices, probabilities, number_of_jobs)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n        \n    # Job two has to be completed first\n    for i in range(number_of_jobs):\n        if i != 1:\n            m += (end[i, 5] > end[1, 5])\n\n    # Objective\n    m.minimize(sum(weights*(end[:, number_of_tasks -1] - release_times)))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Total Weighted Flowtime:\", sum(weights*(end[:, number_of_machines-1].value() - release_times)))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 5 jobs and 5 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total weighted flowtime. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: The first task related to each job shoub be completed before the completion of any job."
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 5  \nnumber_of_machines = 5  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\nweight_choices = [1, 2, 4]\nprobabilities = [0.2, 0.6, 0.2]\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\ndef get_weights(weight_choices, probabilities, number_of_jobs):\n    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\nweights = get_weights(weight_choices, probabilities, number_of_jobs)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n        \n    # The first task related to each job shoub be completed before the completion of any job\n    for i in range(number_of_jobs):\n        m += (end[:, 0] <= end[i, 4])\n\n    # Objective\n    m.minimize(sum(weights*(end[:, number_of_tasks -1] - release_times)))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Total Weighted Flowtime:\", sum(weights*(end[:, number_of_machines-1].value() - release_times)))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 5 jobs and 5 machines. All jobs have random routes and their operations have random durations. The objective function is makespan. Maximum duration is 17. After solving the problem, solutions will be printed and visualised. Note: Job two and four will have task durations in minutes. Other jobs will have task durations in seconds"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 5  \nnumber_of_machines = 5  \nmaximum_duration = 17\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    durations = []\n    for i in range(number_of_jobs):\n        if(i==1 or i==3):\n            durations.append([random.randint(1, maximum_duration)*60 for _ in  range(number_of_machines)]) \n        else:\n            durations.append([random.randint(1, maximum_duration) for _ in  range(number_of_machines)])\n        \n    return durations\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    \n    # model\n    m = Model()\n    \n    # constraints\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n\n    # Objective\n    m.minimize(max(end))\n\n    return m, (start, end)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end)) = model(jobs, last_time, durations, task_to_machine_mapping)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Makespan:\", max(end.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 7 jobs and 5 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. The objective function is maximum tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Fifth task of Job five should be the last task to complete"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 7  \nnumber_of_machines = 5  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n        \n    # Fifth task of Job five should be the last task to complete\n    for i in range(number_of_jobs):\n        if i != 4:\n            m += (end[i, 4] <= start[4, 4])\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n\n    # Objective\n    m.minimize(max(tardiness))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Max Tardiness:\", max(tardiness.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 4 jobs and 4 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. The objective function is maximum tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised."
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 4  \nnumber_of_machines = 4  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n\n    # Objective\n    m.minimize(max(tardiness))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Max Tardiness:\", max(tardiness.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 4 jobs and 5 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. The objective function is maximum tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised.Note: Job two has to be completed first"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 4  \nnumber_of_machines = 5  \nmaximum_duration = 20\ndue_date_allowance = 1.3\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    \n    # model\n    m = Model()\n    \n    # constraints\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n        \n    # Job two has to be completed first\n    for i in range(number_of_jobs):\n        if i != 1:\n            m += (end[i, 4] > end[1, 4]) \n\n    # Objective\n    m.minimize(max(tardiness))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Max Tardiness:\", max(tardiness.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 6 jobs and 6 machines. All jobs have random routes and their operations have random durations. The objective function is makespan. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: sixth task of Job six should be the last task to complete"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 6  \nnumber_of_machines = 6  \nmaximum_duration = 20\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    \n    # model\n    m = Model()\n    \n    # constraints\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # Sixth task of Job six should be the last task to complete\n    for i in range(number_of_jobs):\n        if i != 5:\n            m += (end[i, 5] <= start[5, 5])\n\n    # Objective\n    m.minimize(max(end))\n\n    return m, (start, end)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end)) = model(jobs, last_time, durations, task_to_machine_mapping)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Makespan:\", max(end.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 6 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total weighted flowtime. Maximum duration is 20. After solving the problem, solutions will be printed and visualised."
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 6  \nnumber_of_machines = 6  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\nweight_choices = [1, 2, 4]\nprobabilities = [0.2, 0.6, 0.2]\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\ndef get_weights(weight_choices, probabilities, number_of_jobs):\n    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\nweights = get_weights(weight_choices, probabilities, number_of_jobs)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n\n    # Objective\n    m.minimize(sum(weights*(end[:, number_of_tasks -1] - release_times)))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Total Weighted Flowtime:\", sum(weights*(end[:, number_of_machines-1].value() - release_times)))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 7 jobs and 6 machines. All jobs have random routes and their operations have random durations. The objective function is makespan. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: sixth task of Job six should be the last task to complete"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 7  \nnumber_of_machines = 6  \nmaximum_duration = 20\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    \n    # model\n    m = Model()\n    \n    # constraints\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # Sixth task of Job six should be the last task to complete\n    for i in range(number_of_jobs):\n        if i != 5:\n            m += (end[i, 5] <= start[5, 5])\n\n    # Objective\n    m.minimize(max(end))\n\n    return m, (start, end)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end)) = model(jobs, last_time, durations, task_to_machine_mapping)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Makespan:\", max(end.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 6 jobs and 5 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. The objective function is maximum tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: The first task related to each job shoub be completed before the completion of any job."
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 6  \nnumber_of_machines = 5  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n        \n    # The first task related to each job shoub be completed before the completion of any job\n    for i in range(number_of_jobs):\n        m += (end[:, 0] <= end[i, 4])\n\n    # Objective\n    m.minimize(max(tardiness))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Max Tardiness:\", max(tardiness.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 6 jobs and 6 machines. All jobs have random routes and their operations have random durations. The objective function is makespan. Maximum duration is 20. After solving the problem, solutions will be printed and visualised."
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 6  \nnumber_of_machines = 6  \nmaximum_duration = 20\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    \n    # model\n    m = Model()\n    \n    # constraints\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n\n    # Objective\n    m.minimize(max(end))\n\n    return m, (start, end)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end)) = model(jobs, last_time, durations, task_to_machine_mapping)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Makespan:\", max(end.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 7 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total weighted flowtime. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Sixth task of Job five should be the last task to complete"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 7  \nnumber_of_machines = 6  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\nweight_choices = [1, 2, 4]\nprobabilities = [0.2, 0.6, 0.2]\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\ndef get_weights(weight_choices, probabilities, number_of_jobs):\n    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\nweights = get_weights(weight_choices, probabilities, number_of_jobs)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n        \n    # Sixth task of Job five should be the last task to complete\n    for i in range(number_of_jobs):\n        if i != 4:\n            m += (end[i, 5] <= start[4, 5])\n\n    # Objective\n    m.minimize(sum(weights*(end[:, number_of_tasks -1] - release_times)))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Total Weighted Flowtime:\", sum(weights*(end[:, number_of_machines-1].value() - release_times)))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 4 jobs and 4 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. The objective function is maximum tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Job two and four will have task durations in minutes. Other jobs will have task durations in seconds"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 4  \nnumber_of_machines = 4  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    durations = []\n    for i in range(number_of_jobs):\n        if(i==1 or i==3):\n            durations.append([random.randint(1, maximum_duration)*60 for _ in  range(number_of_machines)]) \n        else:\n            durations.append([random.randint(1, maximum_duration) for _ in  range(number_of_machines)])\n        \n    return durations\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n\n    # Objective\n    m.minimize(max(tardiness))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Max Tardiness:\", max(tardiness.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 7 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total weighted flowtime. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: The first task related to each job shoub be completed before the completion of any job."
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 7  \nnumber_of_machines = 6  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\nweight_choices = [1, 2, 4]\nprobabilities = [0.2, 0.6, 0.2]\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\ndef get_weights(weight_choices, probabilities, number_of_jobs):\n    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\nweights = get_weights(weight_choices, probabilities, number_of_jobs)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n        \n    # The first task related to each job shoub be completed before the completion of any job\n    for i in range(number_of_jobs):\n        m += (end[:, 0] <= end[i, 5])\n\n    # Objective\n    m.minimize(sum(weights*(end[:, number_of_tasks -1] - release_times)))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Total Weighted Flowtime:\", sum(weights*(end[:, number_of_machines-1].value() - release_times)))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 5 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total flow time (completion time - release time). Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Sixth task of Job five should be the last task to complete"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 5  \nnumber_of_machines = 6  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\nweight_choices = [1, 2, 4]\nprobabilities = [0.2, 0.6, 0.2]\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\ndef get_weights(weight_choices, probabilities, number_of_jobs):\n    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\nweights = get_weights(weight_choices, probabilities, number_of_jobs)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n        \n    # Sixth task of Job five should be the last task to complete\n    for i in range(number_of_jobs):\n        if i != 4:\n            m += (end[i, 5] <= start[4, 5])\n\n    # Objective\n    m.minimize(sum(end[:, number_of_tasks -1] - release_times))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Total Flowtime:\", sum(end[:, number_of_machines-1].value() - release_times))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 7 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total weighted tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: The first task related to each job shoub be completed before the completion of any job."
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 7  \nnumber_of_machines = 6  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\nweight_choices = [1, 2, 4]\nprobabilities = [0.2, 0.6, 0.2]\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\ndef get_weights(weight_choices, probabilities, number_of_jobs):\n    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\nweights = get_weights(weight_choices, probabilities, number_of_jobs)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n        \n    # The first task related to each job shoub be completed before the completion of any job\n    for i in range(number_of_jobs):\n        m += (end[:, 0] <= end[i, 5])\n\n    # Objective\n    m.minimize(sum(weights*tardiness))\n\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Total Weighted Tardiness:\", sum(weights*tardiness.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 5 jobs and 5 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. The objective function is maximum tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: The first task related to each job shoub be completed before the completion of any job."
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 5  \nnumber_of_machines = 5  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n        \n    # The first task related to each job shoub be completed before the completion of any job\n    for i in range(number_of_jobs):\n        m += (end[:, 0] <= end[i, 4])\n\n    # Objective\n    m.minimize(max(tardiness))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Max Tardiness:\", max(tardiness.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 7 jobs and 6 machines. All jobs have random routes and their operations have random durations. The objective function is makespan. Maximum duration is 23. After solving the problem, solutions will be printed and visualised. Note: sixth task of Job six should be the last task to complete"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 7  \nnumber_of_machines = 6  \nmaximum_duration = 23\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    \n    # model\n    m = Model()\n    \n    # constraints\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # Sixth task of Job six should be the last task to complete\n    for i in range(number_of_jobs):\n        if i != 5:\n            m += (end[i, 5] <= start[5, 5])\n\n    # Objective\n    m.minimize(max(end))\n\n    return m, (start, end)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end)) = model(jobs, last_time, durations, task_to_machine_mapping)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Makespan:\", max(end.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 5 jobs and 5 machines. All jobs have random routes and their operations have random durations. The objective function is makespan. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Second task of Job two has to come before all the second tasks of other jobs"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 5  \nnumber_of_machines = 5  \nmaximum_duration = 20\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    \n    # model\n    m = Model()\n    \n    # constraints\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # The 2nd task of job 2 has to come before all 2nd tasks of other jobs\n    for i in range(number_of_jobs):\n        if i != 1:\n            m += (start[i, 1] >= start[1, 1])\n\n    # Objective\n    m.minimize(max(end))\n\n    return m, (start, end)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end)) = model(jobs, last_time, durations, task_to_machine_mapping)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Makespan:\", max(end.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 5 jobs and 5 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. The objective function is maximum tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. The first task related to each job shoub be completed before the completion of any job"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 5  \nnumber_of_machines = 5  \nmaximum_duration = 20\ndue_date_allowance = 1.3\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    \n    # model\n    m = Model()\n    \n    # constraints\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n    \n    # The first task related to each job shoub be completed before the completion of any job\n    for i in range(number_of_jobs):\n        m += (end[:, 0] <= end[i, 4])\n        \n    # Objective\n    m.minimize(max(tardiness))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Max Tardiness:\", max(tardiness.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 6 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. The objective function is maximum tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised."
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 6  \nnumber_of_machines = 6  \nmaximum_duration = 20\ndue_date_allowance = 1.3\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    \n    # model\n    m = Model()\n    \n    # constraints\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n\n    # Objective\n    m.minimize(max(tardiness))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Max Tardiness:\", max(tardiness.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 5 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total weighted tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: The first task related to each job shoub be completed before the completion of any job."
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 5  \nnumber_of_machines = 6  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\nweight_choices = [1, 2, 4]\nprobabilities = [0.2, 0.6, 0.2]\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\ndef get_weights(weight_choices, probabilities, number_of_jobs):\n    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\nweights = get_weights(weight_choices, probabilities, number_of_jobs)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n        \n    # The first task related to each job shoub be completed before the completion of any job\n    for i in range(number_of_jobs):\n        m += (end[:, 0] <= end[i, 5])\n\n    # Objective\n    m.minimize(sum(weights*tardiness))\n\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Total Weighted Tardiness:\", sum(weights*tardiness.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 7 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total weighted tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Job two has to be completed first"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 7  \nnumber_of_machines = 6  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\nweight_choices = [1, 2, 4]\nprobabilities = [0.2, 0.6, 0.2]\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\ndef get_weights(weight_choices, probabilities, number_of_jobs):\n    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\nweights = get_weights(weight_choices, probabilities, number_of_jobs)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n        \n    # Job two has to be completed first\n    for i in range(number_of_jobs):\n        if i != 1:\n            m += (end[i, 5] > end[1, 5])\n\n    # Objective\n    m.minimize(sum(weights*tardiness))\n\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Total Weighted Tardiness:\", sum(weights*tardiness.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 7 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total weighted tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Sixth task of Job five should be the last task to complete."
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 7  \nnumber_of_machines = 6  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\nweight_choices = [1, 2, 4]\nprobabilities = [0.2, 0.6, 0.2]\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\ndef get_weights(weight_choices, probabilities, number_of_jobs):\n    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\nweights = get_weights(weight_choices, probabilities, number_of_jobs)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n        \n    # Sixth task of Job five should be the last task to complete\n    for i in range(number_of_jobs):\n        if i != 4:\n            m += (end[i, 5] <= start[4, 5])\n\n    # Objective\n    m.minimize(sum(weights*tardiness))\n\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Total Weighted Tardiness:\", sum(weights*tardiness.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 5 jobs and 5 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. The objective function is maximum tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Job two and four will have task durations in minutes. Other jobs will have task durations in seconds"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 5  \nnumber_of_machines = 5  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    durations = []\n    for i in range(number_of_jobs):\n        if(i==1 or i==3):\n            durations.append([random.randint(1, maximum_duration)*60 for _ in  range(number_of_machines)]) \n        else:\n            durations.append([random.randint(1, maximum_duration) for _ in  range(number_of_machines)])\n        \n    return durations\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n\n    # Objective\n    m.minimize(max(tardiness))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Max Tardiness:\", max(tardiness.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 6 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total flow time (completion time - release time). Maximum duration is 20. Note: Job two and four will have task durations in minutes. Other jobs will have task durations in seconds"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 6  \nnumber_of_machines = 6  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\nweight_choices = [1, 2, 4]\nprobabilities = [0.2, 0.6, 0.2]\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    durations = []\n    for i in range(number_of_jobs):\n        if(i==1 or i==3):\n            durations.append([random.randint(1, maximum_duration)*60 for _ in  range(number_of_machines)]) \n        else:\n            durations.append([random.randint(1, maximum_duration) for _ in  range(number_of_machines)])\n        \n    return durations\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\ndef get_weights(weight_choices, probabilities, number_of_jobs):\n    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\nweights = get_weights(weight_choices, probabilities, number_of_jobs)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n\n    # Objective\n    m.minimize(sum(end[:, number_of_tasks -1] - release_times))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Total Flowtime:\", sum(end[:, number_of_machines-1].value() - release_times))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 7 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total flow time (completion time - release time). Maximum duration is 20. Note: The first task related to each job shoub be completed before the completion of any job."
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 7  \nnumber_of_machines = 6  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\nweight_choices = [1, 2, 4]\nprobabilities = [0.2, 0.6, 0.2]\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\ndef get_weights(weight_choices, probabilities, number_of_jobs):\n    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\nweights = get_weights(weight_choices, probabilities, number_of_jobs)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n        \n    # The first task related to each job shoub be completed before the completion of any job\n    for i in range(number_of_jobs):\n        m += (end[:, 0] <= end[i, 5])\n\n    # Objective\n    m.minimize(sum(end[:, number_of_tasks -1] - release_times))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Total Flowtime:\", sum(end[:, number_of_machines-1].value() - release_times))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 5 jobs and 5 machines. All jobs have random routes and their operations have random durations. The objective function is makespan. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Job two has to be completed first"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 5  \nnumber_of_machines = 5  \nmaximum_duration = 20\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    \n    # model\n    m = Model()\n    \n    # constraints\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # Job two has to be completed first\n    for i in range(number_of_jobs):\n        if i != 1:\n            m += (end[i, 4] > end[1, 4])\n\n    # Objective\n    m.minimize(max(end))\n\n    return m, (start, end)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end)) = model(jobs, last_time, durations, task_to_machine_mapping)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Makespan:\", max(end.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 5 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total weighted flowtime. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Sixth task of Job five should be the last task to complete"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 5  \nnumber_of_machines = 6  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\nweight_choices = [1, 2, 4]\nprobabilities = [0.2, 0.6, 0.2]\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\ndef get_weights(weight_choices, probabilities, number_of_jobs):\n    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\nweights = get_weights(weight_choices, probabilities, number_of_jobs)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n        \n    # Sixth task of Job five should be the last task to complete\n    for i in range(number_of_jobs):\n        if i != 4:\n            m += (end[i, 5] <= start[4, 5])\n\n    # Objective\n    m.minimize(sum(weights*(end[:, number_of_tasks -1] - release_times)))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Total Weighted Flowtime:\", sum(weights*(end[:, number_of_machines-1].value() - release_times)))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 7 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total flow time (completion time - release time). Maximum duration is 20. After solving the problem, solutions will be printed and visualised."
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 7  \nnumber_of_machines = 6  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\nweight_choices = [1, 2, 4]\nprobabilities = [0.2, 0.6, 0.2]\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\ndef get_weights(weight_choices, probabilities, number_of_jobs):\n    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\nweights = get_weights(weight_choices, probabilities, number_of_jobs)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n\n    # Objective\n    m.minimize(sum(end[:, number_of_tasks -1] - release_times))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Total Flowtime:\", sum(end[:, number_of_machines-1].value() - release_times))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 5 jobs and 5 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total flow time (completion time - release time). Maximum duration is 20. Note: Job two and four will have task durations in minutes. Other jobs will have task durations in seconds"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 5  \nnumber_of_machines = 5  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\nweight_choices = [1, 2, 4]\nprobabilities = [0.2, 0.6, 0.2]\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    durations = []\n    for i in range(number_of_jobs):\n        if(i==1 or i==3):\n            durations.append([random.randint(1, maximum_duration)*60 for _ in  range(number_of_machines)]) \n        else:\n            durations.append([random.randint(1, maximum_duration) for _ in  range(number_of_machines)])\n        \n    return durations\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\ndef get_weights(weight_choices, probabilities, number_of_jobs):\n    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\nweights = get_weights(weight_choices, probabilities, number_of_jobs)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n\n    # Objective\n    m.minimize(sum(end[:, number_of_tasks -1] - release_times))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Total Flowtime:\", sum(end[:, number_of_machines-1].value() - release_times))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 4 jobs and 5 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. The objective function is maximum tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: The first task related to each job shoub be completed before the completion of any job."
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 4  \nnumber_of_machines = 5  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n        \n    # The first task related to each job shoub be completed before the completion of any job\n    for i in range(number_of_jobs):\n        m += (end[:, 0] <= end[i, 4])\n\n    # Objective\n    m.minimize(max(tardiness))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Max Tardiness:\", max(tardiness.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 4 jobs and 5 machines. All jobs have random routes and their operations have random durations. The objective function is makespan. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: The first task related to each job should be completed before the completion of any job."
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 4  \nnumber_of_machines = 5  \nmaximum_duration = 20\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    \n    # model\n    m = Model()\n    \n    # constraints\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # The first task related to each job shoub be completed before the completion of any job\n    for i in range(number_of_jobs):\n        m += (end[:, 0] <= end[i, 4])\n\n    # Objective\n    m.minimize(max(end))\n\n    return m, (start, end)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end)) = model(jobs, last_time, durations, task_to_machine_mapping)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Makespan:\", max(end.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 4 jobs and 4 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. The objective function is maximum tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Job two and four will have task durations in minutes. Other jobs will have task durations in seconds"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 4  \nnumber_of_machines = 4  \nmaximum_duration = 20\ndue_date_allowance = 1.3\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    durations = []\n    for i in range(number_of_jobs):\n        if(i==1 or i==3):\n            durations.append([random.randint(1, maximum_duration)*60 for _ in  range(number_of_machines)]) \n        else:\n            durations.append([random.randint(1, maximum_duration) for _ in  range(number_of_machines)])\n        \n    return durations\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    \n    # model\n    m = Model()\n    \n    # constraints\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n\n    # Objective\n    m.minimize(max(tardiness))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Max Tardiness:\", max(tardiness.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 6 jobs and 5 machines. All jobs have random routes and their operations have random durations. The objective function is makespan. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Job two has to be completed first"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 6  \nnumber_of_machines = 5  \nmaximum_duration = 20\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    \n    # model\n    m = Model()\n    \n    # constraints\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # Job two has to be completed first\n    for i in range(number_of_jobs):\n        if i != 1:\n            m += (end[i, 4] > end[1, 4])\n\n    # Objective\n    m.minimize(max(end))\n\n    return m, (start, end)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end)) = model(jobs, last_time, durations, task_to_machine_mapping)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Makespan:\", max(end.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 6 jobs and 5 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. The objective function is maximum tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Fifth task of Job five should be the last task to complete"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 6  \nnumber_of_machines = 5  \nmaximum_duration = 20\ndue_date_allowance = 1.3\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    \n    # model\n    m = Model()\n    \n    # constraints\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n        \n     # Fifth task of Job five should be the last task to complete\n    for i in range(number_of_jobs):\n        if i != 4:\n            m += (end[i, 4] <= start[4, 4])\n\n    # Objective\n    m.minimize(max(tardiness))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Max Tardiness:\", max(tardiness.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 4 jobs and 4 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total flow time (completion time - release time). Maximum duration is 20. After solving the problem, solutions will be printed and visualised."
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 4  \nnumber_of_machines = 4  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\nweight_choices = [1, 2, 4]\nprobabilities = [0.2, 0.6, 0.2]\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\ndef get_weights(weight_choices, probabilities, number_of_jobs):\n    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\nweights = get_weights(weight_choices, probabilities, number_of_jobs)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n\n    # Objective\n    m.minimize(sum(end[:, number_of_tasks -1] - release_times))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Total Flowtime:\", sum(end[:, number_of_machines-1].value() - release_times))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 4 jobs and 4 machines. All jobs have random routes and their operations have random durations. The objective function is makespan. Maximum duration is 10. After solving the problem, solutions will be printed and visualised."
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 4  \nnumber_of_machines = 4  \nmaximum_duration = 10\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    \n    # model\n    m = Model()\n    \n    # constraints\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n\n    # Objective\n    m.minimize(max(end))\n\n    return m, (start, end)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end)) = model(jobs, last_time, durations, task_to_machine_mapping)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Makespan:\", max(end.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 5 jobs and 5 machines. All jobs have random routes and their operations have random durations. The objective function is makespan. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Fifth task of Job five should be the last task to complete"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 5  \nnumber_of_machines = 5  \nmaximum_duration = 20\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    \n    # model\n    m = Model()\n    \n    # constraints\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # Fifth task of Job five should be the last task to complete\n    for i in range(number_of_jobs):\n        if i != 4:\n            m += (end[i, 4] <= start[4, 4])\n\n    # Objective\n    m.minimize(max(end))\n\n    return m, (start, end)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end)) = model(jobs, last_time, durations, task_to_machine_mapping)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Makespan:\", max(end.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 5 jobs and 5 machines. All jobs have random routes and their operations have random durations. The objective function is makespan. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Job two and four will have task durations in minutes. Other jobs will have task durations in seconds"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 5  \nnumber_of_machines = 5  \nmaximum_duration = 20\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    durations = []\n    for i in range(number_of_jobs):\n        if(i==1 or i==3):\n            durations.append([random.randint(1, maximum_duration)*60 for _ in  range(number_of_machines)]) \n        else:\n            durations.append([random.randint(1, maximum_duration) for _ in  range(number_of_machines)])\n        \n    return durations\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    \n    # model\n    m = Model()\n    \n    # constraints\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n\n    # Objective\n    m.minimize(max(end))\n\n    return m, (start, end)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end)) = model(jobs, last_time, durations, task_to_machine_mapping)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Makespan:\", max(end.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 6 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total flow time (completion time - release time). Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Sixth task of Job five should be the last task to complete"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 6  \nnumber_of_machines = 6  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\nweight_choices = [1, 2, 4]\nprobabilities = [0.2, 0.6, 0.2]\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\ndef get_weights(weight_choices, probabilities, number_of_jobs):\n    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\nweights = get_weights(weight_choices, probabilities, number_of_jobs)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n        \n    # Sixth task of Job five should be the last task to complete\n    for i in range(number_of_jobs):\n        if i != 4:\n            m += (end[i, 5] <= start[4, 5])\n\n    # Objective\n    m.minimize(sum(end[:, number_of_tasks -1] - release_times))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Total Flowtime:\", sum(end[:, number_of_machines-1].value() - release_times))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 5 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total weighted tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Job two has to be completed first"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 5  \nnumber_of_machines = 6  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\nweight_choices = [1, 2, 4]\nprobabilities = [0.2, 0.6, 0.2]\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\ndef get_weights(weight_choices, probabilities, number_of_jobs):\n    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\nweights = get_weights(weight_choices, probabilities, number_of_jobs)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n        \n    # Job two has to be completed first\n    for i in range(number_of_jobs):\n        if i != 1:\n            m += (end[i, 5] > end[1, 5])\n\n    # Objective\n    m.minimize(sum(weights*tardiness))\n\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Total Weighted Tardiness:\", sum(weights*tardiness.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 4 jobs and 4 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total weighted tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Job two and four will have task durations in minutes. Other jobs will have task durations in seconds"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 4  \nnumber_of_machines = 4  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\nweight_choices = [1, 2, 4]\nprobabilities = [0.2, 0.6, 0.2]\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    durations = []\n    for i in range(number_of_jobs):\n        if(i==1 or i==3):\n            durations.append([random.randint(1, maximum_duration)*60 for _ in  range(number_of_machines)]) \n        else:\n            durations.append([random.randint(1, maximum_duration) for _ in  range(number_of_machines)])\n        \n    return durations\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\ndef get_weights(weight_choices, probabilities, number_of_jobs):\n    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\nweights = get_weights(weight_choices, probabilities, number_of_jobs)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n\n    # Objective\n    m.minimize(sum(weights*tardiness))\n\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Total Weighted Tardiness:\", sum(weights*tardiness.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 4 jobs and 4 machines. All jobs have random routes and their operations have random durations. The objective function is makespan. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Second task of Job two has to come before all the second tasks of other jobs"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 4  \nnumber_of_machines = 4  \nmaximum_duration = 20\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    \n    # model\n    m = Model()\n    \n    # constraints\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # The 2nd task of job 2 has to come before all 2nd tasks of other jobs\n    for i in range(number_of_jobs):\n        if i != 1:\n            m += (start[i, 1] >= start[1, 1])\n\n    # Objective\n    m.minimize(max(end))\n\n    return m, (start, end)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end)) = model(jobs, last_time, durations, task_to_machine_mapping)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Makespan:\", max(end.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 4 jobs and 4 machines. All jobs have random routes and their operations have random durations. The objective function is makespan. Maximum duration is 20. After solving the problem, solutions will be printed and visualised."
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 4  \nnumber_of_machines = 4  \nmaximum_duration = 20\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    \n    # model\n    m = Model()\n    \n    # constraints\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n\n    # Objective\n    m.minimize(max(end))\n\n    return m, (start, end)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end)) = model(jobs, last_time, durations, task_to_machine_mapping)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Makespan:\", max(end.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 7 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total weighted flowtime. Maximum duration is 20. After solving the problem, solutions will be printed and visualised."
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 7  \nnumber_of_machines = 6  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\nweight_choices = [1, 2, 4]\nprobabilities = [0.2, 0.6, 0.2]\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\ndef get_weights(weight_choices, probabilities, number_of_jobs):\n    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\nweights = get_weights(weight_choices, probabilities, number_of_jobs)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n\n    # Objective\n    m.minimize(sum(weights*(end[:, number_of_tasks -1] - release_times)))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Total Weighted Flowtime:\", sum(weights*(end[:, number_of_machines-1].value() - release_times)))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 6 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total weighted flowtime. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Job two has to be completed first."
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 6  \nnumber_of_machines = 6  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\nweight_choices = [1, 2, 4]\nprobabilities = [0.2, 0.6, 0.2]\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\ndef get_weights(weight_choices, probabilities, number_of_jobs):\n    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\nweights = get_weights(weight_choices, probabilities, number_of_jobs)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n        \n    # Job two has to be completed first\n    for i in range(number_of_jobs):\n        if i != 1:\n            m += (end[i, 5] > end[1, 5])\n\n    # Objective\n    m.minimize(sum(weights*(end[:, number_of_tasks -1] - release_times)))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Total Weighted Flowtime:\", sum(weights*(end[:, number_of_machines-1].value() - release_times)))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 7 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total weighted tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Job two and four will have task durations in minutes. Other jobs will have task durations in seconds"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 7  \nnumber_of_machines = 6  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\nweight_choices = [1, 2, 4]\nprobabilities = [0.2, 0.6, 0.2]\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    durations = []\n    for i in range(number_of_jobs):\n        if(i==1 or i==3):\n            durations.append([random.randint(1, maximum_duration)*60 for _ in  range(number_of_machines)]) \n        else:\n            durations.append([random.randint(1, maximum_duration) for _ in  range(number_of_machines)])\n        \n    return durations\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\ndef get_weights(weight_choices, probabilities, number_of_jobs):\n    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\nweights = get_weights(weight_choices, probabilities, number_of_jobs)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n\n    # Objective\n    m.minimize(sum(weights*tardiness))\n\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Total Weighted Tardiness:\", sum(weights*tardiness.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 5 jobs and 5 machines. All jobs have random routes and their operations have random durations. The objective function is makespan. Maximum duration is 20. After solving the problem, solutions will be printed and visualised"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 5  \nnumber_of_machines = 5  \nmaximum_duration = 20\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    \n    # model\n    m = Model()\n    \n    # constraints\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n\n    # Objective\n    m.minimize(max(end))\n\n    return m, (start, end)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end)) = model(jobs, last_time, durations, task_to_machine_mapping)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Makespan:\", max(end.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 7 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total weighted flowtime. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Job two and four will have task durations in minutes. Other jobs will have task durations in seconds."
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 7  \nnumber_of_machines = 6  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\nweight_choices = [1, 2, 4]\nprobabilities = [0.2, 0.6, 0.2]\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    durations = []\n    for i in range(number_of_jobs):\n        if(i==1 or i==3):\n            durations.append([random.randint(1, maximum_duration)*60 for _ in  range(number_of_machines)]) \n        else:\n            durations.append([random.randint(1, maximum_duration) for _ in  range(number_of_machines)])\n        \n    return durations\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\ndef get_weights(weight_choices, probabilities, number_of_jobs):\n    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\nweights = get_weights(weight_choices, probabilities, number_of_jobs)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n\n    # Objective\n    m.minimize(sum(weights*(end[:, number_of_tasks -1] - release_times)))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Total Weighted Flowtime:\", sum(weights*(end[:, number_of_machines-1].value() - release_times)))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 7 jobs and 5 machines. All jobs have random routes and their operations have random durations. The objective function is makespan. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Job two has to be completed first"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 7  \nnumber_of_machines = 5  \nmaximum_duration = 20\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    \n    # model\n    m = Model()\n    \n    # constraints\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # Job two has to be completed first\n    for i in range(number_of_jobs):\n        if i != 1:\n            m += (end[i, 4] > end[1, 4])\n\n    # Objective\n    m.minimize(max(end))\n\n    return m, (start, end)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end)) = model(jobs, last_time, durations, task_to_machine_mapping)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Makespan:\", max(end.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 6 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. The objective function is maximum tardiness. Maximum duration is 30. After solving the problem, solutions will be printed and visualised."
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 6  \nnumber_of_machines = 6  \nmaximum_duration = 30\ndue_date_allowance = 1.3\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    \n    # model\n    m = Model()\n    \n    # constraints\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n\n    # Objective\n    m.minimize(max(tardiness))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Max Tardiness:\", max(tardiness.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 5 jobs and 5 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total weighted flowtime. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Job two and four will have task durations in minutes. Other jobs will have task durations in seconds."
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 5  \nnumber_of_machines = 5  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\nweight_choices = [1, 2, 4]\nprobabilities = [0.2, 0.6, 0.2]\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    durations = []\n    for i in range(number_of_jobs):\n        if(i==1 or i==3):\n            durations.append([random.randint(1, maximum_duration)*60 for _ in  range(number_of_machines)]) \n        else:\n            durations.append([random.randint(1, maximum_duration) for _ in  range(number_of_machines)])\n        \n    return durations\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\ndef get_weights(weight_choices, probabilities, number_of_jobs):\n    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\nweights = get_weights(weight_choices, probabilities, number_of_jobs)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    # model\n    m = Model()\n    \n    # constraints\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n\n    # Objective\n    m.minimize(sum(weights*(end[:, number_of_tasks -1] - release_times)))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Total Weighted Flowtime:\", sum(weights*(end[:, number_of_machines-1].value() - release_times)))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 5 jobs and 5 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. The objective function is maximum tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Job two and four will have task durations in minutes. Other jobs will have task durations in seconds"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 5  \nnumber_of_machines = 5  \nmaximum_duration = 20\ndue_date_allowance = 1.3\n\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    durations = []\n    for i in range(number_of_jobs):\n        if(i==1 or i==3):\n            durations.append([random.randint(1, maximum_duration)*60 for _ in  range(number_of_machines)]) \n        else:\n            durations.append([random.randint(1, maximum_duration) for _ in  range(number_of_machines)])\n        \n    return durations\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]\n\ndef get_jobs(number_of_jobs):\n    return [f\"Job Number{i+1}\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n\n\n# model\ndef model(jobs, last_time, durations, task_to_machine_mapping, due_dates):\n    durations = np.array(durations)\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"start\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"end\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"tardiness\")  # tardiness of each job\n\n    \n    # model\n    m = Model()\n    \n    # constraints\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n\n    # Objective\n    m.minimize(max(tardiness))\n\n    return m, (start, end, tardiness)\n\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    task_to_machine_mapping = np.array(task_to_machine_mapping)\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"Task {j}_{t}\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"Start\", x=\"Time\", y=\"Machine\", color=\"Job\", text=\"Name\")\n    return fig.show()\n\n# variables, constraints, and the model\n(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"No solution found.\")\n    \n# output\nprint(\"Max Tardiness:\", max(tardiness.value()))\nprint(\"Start times:\", start.value())\nprint(\"End times:\", end.value())\nprint(\"Tardiness:\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            }
        ]
    ]
}
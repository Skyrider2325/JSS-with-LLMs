PD_index,Description,Prob_Formulation,pf_gemma_2b_ft,pf_gpt_zs,pf_gpt_os,pf_gpt_fs_rag,pf_gpt_zs_eval,pf_gpt_os_eval,pf_gpt_fs_rag_eval,pf_gemma_2b_ft_eval
1,"Create job shop scheduling model with 6 jobs and 5 machines. All jobs have random routes and their operations have random durations. The objective function is makespan. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: The first task related to each job should be completed before the completion of any job.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 6  
number_of_machines = 5  
maximum_duration = 20

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(durations)

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)


# model
def model(jobs, last_time, durations, task_to_machine_mapping):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    
    # model
    m = Model()
    
    # constraints
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # The first task related to each job shoub be completed before the completion of any job
    for i in range(number_of_jobs):
        m += (end[:, 0] <= end[i, 4])

    # Objective
    m.minimize(max(end))

    return m, (start, end)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end)) = model(jobs, last_time, durations, task_to_machine_mapping)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Makespan:"", max(end.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())","import pandas as pd
import numpy as np
import lmfit
from lmfit import Minim
import random
import matplotlib.pyplot as plt

# Define the problem
num_jobs = 6
num_machines = 5
duration_max = 20
rate = [1,1,1,1,1]
setup_time = [0,0,0,0,0]
residuals = []
durations = []
visual_times = []
visual_residuals = []
for i in range(num_jobs):
    if i == 0 or i == 2 or i == 4:
        durations.append(random.uniform(1, duration_max) * rate[i])
    else:
        durations.append(random.uniform(1, duration_max) * rate[i])
    visual_times.append(random.uniform(1, duration_max) * rate[i])
    residuals.append(durations[i] - rate[i] * setup_time[i])
visual_residuals.append(durations)
visual_times.append(0)
visual_residuals.append(0)

# Define the objective function
def f(params):
    return sum(r * d for r, d in zip(rate, durations)) - sum(r * setup_time for r, setup_time in zip(rate, visual_times))

# Define the constraints
def con(params):
    return [
        sum(a) - 1 for a in range(num_jobs)
        if a == 0 or a == 2 or a == 4
        else:
            sum(a) - 1
        for a in range(num_jobs)
    ]

# Solve the problem
params = Minim(f, con, args=(), bounds=(0, 1000), callbacks=100, nester=""adam"", maxiter=1000)

# Print the results
print(""Best solution:"")
print(params.best_values_)
print(""Best objective value:"", f(params.best_values_))

# Visualize the results
plt.figure(figsize=(10, 8))
for i, visual in enumerate(visual_times):
    plt.plot(visual_times[i], visual_residuals[i])
plt.plot(visual_times[i], visual_residuals[i], label=""durations"")
plt.plot(visual_times[i], visual_residuals[i], label=""setup time"")
plt.legend()
plt.show()

print(""Minimum residual:"", np.min(residuals))
print(""Maximum residual:"", np.max(residuals))
print(""Minimum durations:"", np.min(durations))
print(""Maximum durations:"", np.max(durations))
print(""Minimum times:"", np.min(visual_times))
print(""Maximum times:"", np.max(visual_times))
print(""Total running time:"", params.best_values_[0] * 60, ""minutes"")
print(""Total setup time:"", params.best_values_[1] * 60, ""minutes"")
print(""Total completion time:"", params.best_values_[0] * 60, ""minutes"")
print(""Makespan:"", params.best_values_[0] * 60, ""minutes"")
","import random
from cpmpy import *
import numpy as np

# Constants
num_jobs = 6
num_machines = 5
max_duration = 20

# Randomly generate routes and durations
jobs = []
for j in range(num_jobs):
    num_operations = random.randint(1, num_machines)
    route = random.sample(range(num_machines), num_operations)
    durations = [random.randint(1, max_duration) for _ in range(num_operations)]
    jobs.append(list(zip(route, durations)))

# Variables
makespan = intvar(0, sum(d[1] for job in jobs for d in job), name=""makespan"")
start_times = [[intvar(0, makespan) for _ in job] for job in jobs]
end_times = [[start_times[j][o] + jobs[j][o][1] for o in range(len(jobs[j]))] for j in range(num_jobs)]

# Constraints
constraints = []

# Ensure operations are scheduled in order for each job
for j in range(num_jobs):
    for o in range(1, len(jobs[j])):
        constraints.append(end_times[j][o-1] <= start_times[j][o])

# Ensure tasks on the same machine do not overlap
for m in range(num_machines):
    machine_tasks = []
    for j in range(num_jobs):
        for o, (machine, duration) in enumerate(jobs[j]):
            if machine == m:
                machine_tasks.append((start_times[j][o], end_times[j][o]))
    for t1, t2 in itertools.combinations(machine_tasks, 2):
        constraints.append(t1[1] <= t2[0] | t2[1] <= t1[0])

# Ensure the first task of each job completes before any job completes
for j in range(num_jobs):
    constraints.append(end_times[j][0] <= makespan)

# Objective
objective = minimize(makespan)

# Model
model = Model(constraints + [objective])

# Solve
solution = model.solve()

# Output
if solution:
    for j in range(num_jobs):
        print(f""Job {j}:"")
        for o in range(len(jobs[j])):
            print(f""  Operation {o} on machine {jobs[j][o][0]} starts at {start_times[j][o].value()} ends at {end_times[j][o].value()}"")
    print(f""Makespan: {makespan.value()}"")
else:
    print(""No solution found"")
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 6  
number_of_machines = 5  
maximum_duration = 20

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(durations)

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)

# model
def model(jobs, last_time, durations, task_to_machine_mapping):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task

    # model
    m = Model()

    # constraints
    m += (end == start + durations)  # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # The first task related to each job should be completed before the completion of any job
    for j in range(number_of_jobs):
        for k in range(number_of_jobs):
            if j != k:
                m += (end[j, 0] <= end[k, number_of_tasks - 1])

    # Objective: Minimize makespan
    makespan = max(end[:, number_of_tasks - 1])
    m.minimize(makespan)

    return m, (start, end, makespan)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start, end, makespan)) = model(jobs, last_time, durations, task_to_machine_mapping)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Makespan:"", makespan.value())
print(""Start times:"", start.value())
print(""End times:"", end.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 6  
number_of_machines = 5  
maximum_duration = 20

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(durations)

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)

# model
def model(jobs, last_time, durations, task_to_machine_mapping):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task

    # model
    m = Model()

    # constraints
    m += (end == start + durations)  # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # The first task related to each job should be completed before the completion of any job
    for j in range(number_of_jobs):
        for k in range(number_of_jobs):
            if j != k:
                m += (end[j, 0] <= end[k, number_of_tasks - 1])

    # Objective: Minimize makespan
    makespan = max(end[:, number_of_tasks - 1])
    m.minimize(makespan)

    return m, (start, end, makespan)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start, end, makespan)) = model(jobs, last_time, durations, task_to_machine_mapping)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Makespan:"", makespan.value())
print(""Start times:"", start.value())
print(""End times:"", end.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())",Invalid: name 'max_duration' is not defined,Valid,Valid,"Invalid: invalid syntax (<string>, line 38)"
2,"Create job shop scheduling model with 7 jobs and 7 machines. All jobs have random routes and their operations have random durations. The objective function is makespan. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Job two and four will have task durations in minutes. Other jobs will have task durations in seconds","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 7  
number_of_machines = 7  
maximum_duration = 20

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    durations = []
    for i in range(number_of_jobs):
        if(i==1 or i==3):
            durations.append([random.randint(1, maximum_duration)*60 for _ in  range(number_of_machines)]) 
        else:
            durations.append([random.randint(1, maximum_duration) for _ in  range(number_of_machines)])
        
    return durations

def get_last_time(durations):
    return sum(durations)

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)


# model
def model(jobs, last_time, durations, task_to_machine_mapping):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    
    # model
    m = Model()
    
    # constraints
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]

    # Objective
    m.minimize(max(end))

    return m, (start, end)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end)) = model(jobs, last_time, durations, task_to_machine_mapping)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Makespan:"", max(end.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())",**Output:**,"import numpy as np
import cpmpy as cp

# Problem parameters
num_jobs = 7
num_machines = 7
max_duration = 20

# Random seed for reproducibility
np.random.seed(0)

# Generate random routes and durations
routes = [np.random.permutation(num_machines).tolist() for _ in range(num_jobs)]
durations = [[np.random.randint(1, max_duration + 1) for _ in range(num_machines)] for _ in range(num_jobs)]

# Adjust durations for job 2 and job 4 to minutes
for op in range(num_machines):
    durations[1][op] *= 60  # Job 2
    durations[3][op] *= 60  # Job 4

# Variables
start_times = [[cp.intvar(0, sum(durations[j]), name=f""start_{j}_{m}"") for m in range(num_machines)] for j in range(num_jobs)]
end_times = [[start_times[j][m] + durations[j][m] for m in range(num_machines)] for j in range(num_jobs)]
makespan = cp.intvar(0, sum([max(durations[j]) for j in range(num_jobs)]), name=""makespan"")

# Constraints
model = cp.Model()

# Precedence constraints within the same job
for j in range(num_jobs):
    for m in range(1, num_machines):
        model += [start_times[j][m] >= end_times[j][m-1]]

# No overlap constraints on the same machine
for m in range(num_machines):
    for j1 in range(num_jobs):
        for j2 in range(j1 + 1, num_jobs):
            model += [
                (end_times[j1][m] <= start_times[j2][routes[j2].index(m)]) | 
                (end_times[j2][m] <= start_times[j1][routes[j1].index(m)])
            ]

# Makespan constraints
for j in range(num_jobs):
    model += [makespan >= end_times[j][-1]]

# Objective
model.minimize(makespan)

# Solve model
solver = cp.Solver.lookup('ortools')
if solver.solve(model):
    for j in range(num_jobs):
        print(f""Job {j+1}:"")
        for m in range(num_machines):
            print(f""  Machine {routes[j][m]+1}: Start at {start_times[j][m].value()}, End at {end_times[j][m].value()}"")
    print(f""Makespan: {makespan.value()}"")
else:
    print(""No solution found."")
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 7
number_of_machines = 7
maximum_duration = 20

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    durations = []
    for job in range(number_of_jobs):
        if job == 1 or job == 3:  # Job 2 and 4 have durations in minutes
            durations.append([random.randint(1, maximum_duration) * 60 for _ in range(number_of_machines)])
        else:
            durations.append([random.randint(1, maximum_duration) for _ in range(number_of_machines)])
    return durations

def get_last_time(durations):
    return sum(map(sum, durations))

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)

# model
def model(jobs, last_time, durations, task_to_machine_mapping):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task

    # model
    m = Model()
    
    # constraints
    m += (end == start + durations)  # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]

    # Objective: minimize makespan
    makespan = max(end[:, -1])
    m.minimize(makespan)

    return m, (start, end, makespan)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start, end, makespan)) = model(jobs, last_time, durations, task_to_machine_mapping)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Makespan:"", makespan.value())
print(""Start times:"", start.value())
print(""End times:"", end.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 7
number_of_machines = 7
maximum_duration = 20

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    durations = []
    for i in range(number_of_jobs):
        if i == 1 or i == 3:  # Job 2 and Job 4 have durations in minutes
            durations.append([random.randint(1, maximum_duration) * 60 for _ in range(number_of_machines)])
        else:  # Other jobs have durations in seconds
            durations.append([random.randint(1, maximum_duration) for _ in range(number_of_machines)])
    return durations

def get_last_time(durations):
    return sum(map(sum, durations))

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)

# model
def model(jobs, last_time, durations, task_to_machine_mapping):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task

    # model
    m = Model()

    # constraints
    m += (end == start + durations)  # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs):
        for t in range(number_of_tasks):
            m += [(end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                  for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                  if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]

    # Objective
    m.minimize(max(end))

    return m, (start, end)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end)) = model(jobs, last_time, durations, task_to_machine_mapping)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max(end.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
",Invalid: name 'num_machines' is not defined,Valid,Valid,"Invalid: invalid syntax (<string>, line 1)"
3,"Create job shop scheduling model with 6 jobs and 5 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. The objective function is maximum tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Job two has to be completed first","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 6  
number_of_machines = 5  
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(durations)

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)


# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m + (start[:, 0] >= release_times)
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))
        
    # Job two has to be completed first
    for i in range(number_of_jobs):
        if i != 1:
            m += (end[i, 4] > end[1, 4])

    # Objective
    m.minimize(max(tardiness))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())","# Python code for Job Shop Scheduling using Job Shop Planner Library
import jobshop
import random
from datetime import datetime

# Define the parameters
num_jobs = 6
num_machines = 5
machine_capacities = [3] * num_machines
due_dates = []
release_times = []
duties = []
max_tardiness = 0

# Define the utility function (maximum tardiness)
def tardiness(tardiness):
    return tardiness

# Define the setup function
def setup(parameters):
    global due_dates
    global release_times
    global duties
    global max_tardiness
    for i in range(num_jobs):
        due_dates.append(random.randint(1, 50)
    for i in range(num_machines):
        release_times.append(random.randint(1, 50)
    for i in range(num_jobs):
        max_tardiness = max(max_tardiness, sum(parameters[i]) * random.randint(1, 3) + random.randint(1, 3))
    return None

# Solve the problem
problem = jobshop.model.JobShopProblem(setup, True)
problem.optimize()

# Print the results
print(""Best tardiness:"", max_tardiness)
print(""Maximum release times:"", release_times)
print(""Maximum setup times:"", [parameters[i] for i in range(num_machines)])
print(""Maximum waiting times:"", [duties[i] for i in range(num_jobs)])

# Visualize the results
visuals = jobshop.io.Visualizer()
visuals.scatter(x=range(len(release_times)), y=range(len(max_tardiness)), labels=range(len(release_times)), c=max_tardiness, s=100, labels_fontsize=10, visualizer_filename=""visual.png"")
visuals.show()","import random
from cpmpy import *

# Constants
num_jobs = 6
num_machines = 5
max_duration = 20
due_date_allowance = 1.3
release_time_bound = 50

# Generate random job data
jobs = []
for job_id in range(num_jobs):
    num_operations = random.randint(1, num_machines)
    operations = [(random.randint(0, num_machines-1), random.randint(1, max_duration)) for _ in range(num_operations)]
    jobs.append(operations)

# Calculate due dates and release times
release_times = [random.randint(0, release_time_bound) for _ in range(num_jobs)]
total_processing_times = [sum(op[1] for op in job) for job in jobs]
due_dates = [int(total * due_date_allowance) for total in total_processing_times]

# Variables
start_times = [[intvar(0, sum(total_processing_times)) for _ in job] for job in jobs]
end_times = [[start_times[j][o] + jobs[j][o][1] for o in range(len(jobs[j]))] for j in range(num_jobs)]
machine_usage = [boolvar(shape=(num_jobs, len(jobs[j]))) for j in range(num_jobs)]

# Constraints
model = Model()

# Job operations must follow the given order
for j in range(num_jobs):
    for o in range(1, len(jobs[j])):
        model += (start_times[j][o] >= end_times[j][o-1])

# Operations must respect release times
for j in range(num_jobs):
    model += (start_times[j][0] >= release_times[j])

# Operations on the same machine cannot overlap
for m in range(num_machines):
    for j1 in range(num_jobs):
        for o1 in range(len(jobs[j1])):
            if jobs[j1][o1][0] == m:
                for j2 in range(num_jobs):
                    for o2 in range(len(jobs[j2])):
                        if jobs[j2][o2][0] == m and (j1 != j2 or o1 != o2):
                            model += (start_times[j1][o1] >= end_times[j2][o2]) | (start_times[j2][o2] >= end_times[j1][o1])

# Objective: Minimize maximum tardiness
tardiness = [intvar(0, sum(total_processing_times)) for _ in range(num_jobs)]
for j in range(num_jobs):
    model += (tardiness[j] >= end_times[j][-1] - due_dates[j])
objective = max(tardiness)

# Job 2 must be completed first
for j in range(num_jobs):
    if j != 1:
        model += (end_times[1][-1] <= end_times[j][-1])

model.minimize(objective)

# Solve the model
solver = CPM_ortools(model)
if solver.solve():
    print(""Objective:"", objective.value())
    for j in range(num_jobs):
        print(f""Job {j}:"")
        for o in range(len(jobs[j])):
            print(f""  Operation {o} (Machine {jobs[j][o][0]}, Duration {jobs[j][o][1]}): Start {start_times[j][o].value()}, End {end_times[j][o].value()}"")
else:
    print(""No solution found"")
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 6  
number_of_machines = 5  
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(map(sum, durations))

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)

# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m += (start[:, 0] >= release_times)
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))
        
    # Job two has to be completed first
    for i in range(number_of_jobs):
        if i != 1:
            m += (end[i, number_of_tasks - 1] > end[1, number_of_tasks - 1])

    # Objective
    m.minimize(max(tardiness))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start, end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Maximum Tardiness:"", max(tardiness.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 6  
number_of_machines = 5  
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(map(sum, durations))

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)


# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m += (start[:, 0] >= release_times)
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # Job two has to be completed first
    for i in range(number_of_jobs):
        if i != 1:
            m += (end[1, -1] <= start[i, 0])
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))

    # Objective
    m.minimize(max(tardiness))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
",Invalid: name 'num_machines' is not defined,Valid,Valid,"Invalid: invalid syntax (<string>, line 27)"
4,"Create job shop scheduling model with 7 jobs and 7 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total weighted flowtime. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: The first task related to each job shoub be completed before the completion of any job.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 7  
number_of_machines = 7  
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50
weight_choices = [1, 2, 4]
probabilities = [0.2, 0.6, 0.2]

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(durations)

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]

def get_weights(weight_choices, probabilities, number_of_jobs):
    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
weights = get_weights(weight_choices, probabilities, number_of_jobs)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)


# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m + (start[:, 0] >= release_times)
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))
        
    # The first task related to each job shoub be completed before the completion of any job
    for i in range(number_of_jobs):
        m += (end[:, 0] <= end[i, 6])

    # Objective
    m.minimize(sum(weights*(end[:, number_of_tasks -1] - release_times)))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Total Weighted Flowtime:"", sum(weights*(end[:, number_of_machines-1].value() - release_times)))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())","# imports
import pandas as pd
import numpy as np
import plotly.express as px
from cpmpy import *
import random

# settings
random.seed(1)
number_of_jobs = 7
number_of_machines = 7
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50
weight_choices = [1, 2, 4]
probabilities = [0.2, 0.6, 0.2]

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    durations = []
    for i in range(number_of_jobs):
        if(i==0):
            durations.append([random.uniform(0, maximum_duration) for _ in  range(number_of_machines)])
        else:
            durations[i]=random.uniform(0, maximum_duration)
    return durations

def get_last_time(durations):
    return sum(durations)

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_weights(number_of_jobs):
    return [random.choice(weight_choices) for _ in range(number_of_jobs)]

def get_last_time_for_job(job_id, durations):
    return sum(durations[i] for i in get_task_to_machine_mapping(number_of_jobs, number_of_machines)[job_id-1])

def get_flow_time(durations, number_of_machines):
    return [last_time(durations) for _ in range(number_of_machines)]+[last_time_for_job(i,durations) for i in range(1,number_of_jobs+1)]

# solving the problem
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
weights = get_weights(number_of_jobs)
last_time_for_job = get_last_time_for_job(i,durations) for i in range(1,number_of_jobs+1)

# creating the model
model = cpmpy.Model()
model.set_params(task_to_machine_mapping=task_to_machine_mapping,
             durations=durations,
             last_time=last_time,
             weights=weights,
             maximum_duration=maximum_duration)

# adding the tasks to the model
for i, task_id in enumerate(task_to_machine_mapping):
    model.add_task(task_to_machine_mapping[i])

# adding the objective function
model.set_objective(get_flow_time, 'total_weighted_flowtime')

# solving the model
model.solve()

# printing the results
print(""optimal durations:"", last_time)
print(""optimal flow time:"", model.get_objective_value())

# visualising the results
figure = px.line(last_time, 'Flowtime', label='Flowtime')
figure.update_layout(title='Job Shop Scheduling', xaxis_title='Time', yaxis_title='Flowtime')
figure.show()","import numpy as np
import cpmpy as cp

# Problem parameters
num_jobs = 7
num_machines = 7
max_duration = 20

# Generating random routes and durations
np.random.seed(0)  # For reproducibility
durations = np.random.randint(1, max_duration + 1, size=(num_jobs, num_machines))
routes = [np.random.permutation(num_machines).tolist() for _ in range(num_jobs)]

# Generating random release times
release_times = np.random.randint(0, 51, size=num_jobs)

# Generating job weights
weights = np.random.choice([1, 2, 4], size=num_jobs, p=[0.2, 0.6, 0.2])

# Calculating due dates
due_dates = np.array([1.3 * durations[job].sum() for job in range(num_jobs)]).astype(int)

# Variables
start_times = cp.intvar(0, sum(durations.flatten()), shape=(num_jobs, num_machines))
completion_times = cp.intvar(0, sum(durations.flatten()), shape=(num_jobs, num_machines))

# Constraints
constraints = []

# Each operation must start after the previous one finishes on the same job
for job in range(num_jobs):
    for op in range(1, num_machines):
        prev_machine = routes[job][op - 1]
        curr_machine = routes[job][op]
        constraints.append(start_times[job, curr_machine] >= completion_times[job, prev_machine])

# Each job must start after its release time
for job in range(num_jobs):
    first_machine = routes[job][0]
    constraints.append(start_times[job, first_machine] >= release_times[job])

# Job operations must respect durations
for job in range(num_jobs):
    for op in range(num_machines):
        machine = routes[job][op]
        constraints.append(completion_times[job, machine] == start_times[job, machine] + durations[job, machine])

# No two jobs can use the same machine at the same time
for machine in range(num_machines):
    for job1 in range(num_jobs):
        for job2 in range(job1 + 1, num_jobs):
            for op1 in range(num_machines):
                for op2 in range(num_machines):
                    if routes[job1][op1] == machine and routes[job2][op2] == machine:
                        constraints.append(cp.any([completion_times[job1, machine] <= start_times[job2, machine], 
                                                   completion_times[job2, machine] <= start_times[job1, machine]]))

# Objective: Minimize total weighted flowtime
flowtimes = [completion_times[job, routes[job][-1]] - release_times[job] for job in range(num_jobs)]
weighted_flowtime = cp.sum([weights[job] * flowtimes[job] for job in range(num_jobs)])

model = cp.Model(constraints, minimize=weighted_flowtime)

# Solve the model
if model.solve():
    print(""Solution found:"")
    for job in range(num_jobs):
        for op in range(num_machines):
            machine = routes[job][op]
            print(f""Job {job} on Machine {machine}: Start at {start_times[job, machine].value()}, End at {completion_times[job, machine].value()}"")
else:
    print(""No solution found."")
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 7  
number_of_machines = 7  
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50
weight_choices = [1, 2, 4]
probabilities = [0.2, 0.6, 0.2]

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(map(sum, durations))

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (due_date_allowance * np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]

def get_weights(weight_choices, probabilities, number_of_jobs):
    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
weights = get_weights(weight_choices, probabilities, number_of_jobs)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)

# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")

    # model
    m = Model()
    
    # constraints
    m += (start[:, 0] >= release_times)
    m += (end == start + durations)

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))
        
    # The first task of each job should be completed before the completion of any job
    for j in range(number_of_jobs):
        for l in range(number_of_jobs):
            if j != l:
                m += (end[j, 0] <= end[l, number_of_tasks - 1])

    # Objective
    total_weighted_flowtime = sum(weights[j] * (end[j, number_of_tasks - 1] - release_times[j]) for j in range(number_of_jobs))
    m.minimize(total_weighted_flowtime)

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start, end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Total Weighted Flowtime:"", sum(weights[j] * (end[j, number_of_tasks - 1].value() - release_times[j]) for j in range(number_of_jobs)))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 7  
number_of_machines = 7  
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50
weight_choices = [1, 2, 4]
probabilities = [0.2, 0.6, 0.2]

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(map(sum, durations))

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0, maximum_release_time) for _ in range(number_of_jobs)]

def get_weights(weight_choices, probabilities, number_of_jobs):
    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
weights = get_weights(weight_choices, probabilities, number_of_jobs)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)

# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m += (start[:, 0] >= release_times)
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))
        
    # The first task related to each job should be completed before the completion of any job
    for i in range(number_of_jobs):
        m += (end[:, 0] <= end[i, -1])

    # Objective
    m.minimize(sum(weights*(end[:, number_of_tasks -1] - release_times)))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Total Weighted Flowtime:"", sum(weights*(end[:, number_of_machines-1].value() - release_times)))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
",Invalid: name 'num_machines' is not defined,Invalid: name 'weights' is not defined,Valid,"Invalid: invalid syntax (<string>, line 48)"
5,"Create job shop scheduling model with 5 jobs and 5 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. The objective function is maximum tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 5  
number_of_machines = 5  
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(durations)

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)


# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m + (start[:, 0] >= release_times)
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))

    # Objective
    m.minimize(max(tardiness))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())","import pandas as pd
import numpy as np
import plotly.express as px
from cpmpy import *
import random
import math
from datetime import datetime
import pandas_datetime as pdm

# Define the problem parameters
num_jobs = 5
num_machines = 5
job_duration_range = [5, 20]
release_range = [0, 50]
due_date_allowance = 1.3
max_duration = 20

# Define the objective function
def max_tardiness(solution):
    return max([job[4] for job in solution])

# Define the constraints
def valid(solution):
    for i in range(num_jobs):
        for j in range(num_machines):
            if solution[i][j] == 1:
                if random.uniform(0, 1) <= random.uniform(*job_duration_range):
                    if random.uniform(0, 1) <= random.uniform(*release_range):
                        if random.uniform(0, 1) <= random.uniform(*due_date_allowance):
                            return False
    return True

# Solve the problem
start_time = time.time()
solution = cp.flow.schedule_job(num_jobs, num_machines, valid, random, max_tardiness)
stop_time = time.time()
print(""Execution time:"", stop_time - start_time, ""seconds"")

# Print the solutions
print(""Solutions:"")
print(solution)

# Visualize the solutions
figure = px.line(solution, labels='tardiness')
figure.update_layout(title='Job Shop Scheduling', xaxis_title='Job Index', yaxis_title='Tardiness')
figure.show()

# Print the maximum tardiness
print(""Maximum tardiness:"", max(solution[4] for solution in solution))","import random
import cpmpy as cp
import numpy as np

# Parameters
num_jobs = 5
num_machines = 5
max_duration = 20

# Random seed for reproducibility
random.seed(42)

# Generate random routes and durations
routes = [random.sample(range(num_machines), num_machines) for _ in range(num_jobs)]
durations = [[random.randint(1, max_duration) for _ in range(num_machines)] for _ in range(num_jobs)]

# Calculate due dates and release times
total_processing_time = [sum(durations[j]) for j in range(num_jobs)]
due_dates = [int(total_processing_time[j] * 1.3) for j in range(num_jobs)]
release_times = [random.randint(0, 50) for _ in range(num_jobs)]

# Variables
start_times = [[cp.intvar(0, sum(total_processing_time)) for _ in range(num_machines)] for _ in range(num_jobs)]
end_times = [[cp.intvar(0, sum(total_processing_time)) for _ in range(num_machines)] for _ in range(num_jobs)]
tardiness = [cp.intvar(0, sum(total_processing_time)) for _ in range(num_jobs)]

# Model
model = cp.Model()

# Constraints
for j in range(num_jobs):
    for i in range(num_machines):
        if i == 0:
            model += (start_times[j][i] >= release_times[j])
        else:
            model += (start_times[j][i] >= end_times[j][i - 1])
        model += (end_times[j][i] == start_times[j][i] + durations[j][i])

for m in range(num_machines):
    for j1 in range(num_jobs):
        for j2 in range(j1 + 1, num_jobs):
            for i1 in range(num_machines):
                for i2 in range(num_machines):
                    if routes[j1][i1] == routes[j2][i2]:
                        model += (end_times[j1][i1] <= start_times[j2][i2]) | (end_times[j2][i2] <= start_times[j1][i1])

for j in range(num_jobs):
    model += (tardiness[j] == cp.max([0, end_times[j][-1] - due_dates[j]]))

# Objective: Minimize maximum tardiness
max_tardiness = cp.intvar(0, sum(total_processing_time))
model += (max_tardiness == cp.max(tardiness))
model.minimize(max_tardiness)

# Solve
if model.solve():
    print(""Solution:"")
    for j in range(num_jobs):
        print(f""Job {j}:"")
        for i in range(num_machines):
            print(f""  Operation {i} on Machine {routes[j][i]}: Start at {start_times[j][i].value()}, End at {end_times[j][i].value()}"")
        print(f""  Tardiness: {tardiness[j].value()}"")
    print(f""Maximum Tardiness: {max_tardiness.value()}"")
else:
    print(""No solution found"")

# Visualization (Optional)
import matplotlib.pyplot as plt

fig, gnt = plt.subplots()
gnt.set_xlabel('Time')
gnt.set_ylabel('Machines')

# Setting Y-axis limits
gnt.set_ylim(0, num_machines + 1)
# Setting X-axis limits
gnt.set_xlim(0, sum(total_processing_time))

# Setting labels for y-axis
gnt.set_yticks([i + 1 for i in range(num_machines)])
gnt.set_yticklabels([f'Machine {i}' for i in range(num_machines)])

# Plotting the jobs
colors = ['red', 'blue', 'green', 'yellow', 'purple']
for j in range(num_jobs):
    for i in range(num_machines):
        gnt.broken_barh([(start_times[j][i].value(), durations[j][i])],
                        (routes[j][i] + 0.5, 0.9),
                        facecolors=(colors[j % len(colors)]))

plt.show()
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 5
number_of_machines = 5
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(sum(durations, []))

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number {i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (due_date_allowance * np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0, maximum_release_time) for _ in range(number_of_jobs)]

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)

# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")

    # model
    m = Model()

    # constraints
    m += (start[:, 0] >= release_times)
    m += (end == start + durations)

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]

    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks - 1] - due_dates[j], 0]))

    # Objective: minimize maximum tardiness
    m.minimize(max(tardiness))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start, end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Maximum Tardiness:"", max(tardiness.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 5  
number_of_machines = 5  
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(map(sum, durations))

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance * np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0, maximum_release_time) for _ in range(number_of_jobs)]

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)

# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m += (start[:, 0] >= release_times)
    m += (end == start + durations)  # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [(end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                  for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                  if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks - 1] - due_dates[j], 0]))

    # Objective
    m.minimize(max(tardiness))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start, end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
",Invalid: name 'num_machines' is not defined,Invalid: sum() takes 1 positional argument but 2 were given,Valid,Invalid: No module named 'pandas_datetime'
6,"Create job shop scheduling model with 5 jobs and 5 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. The objective function is maximum tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 5  
number_of_machines = 5  
maximum_duration = 20
due_date_allowance = 1.3

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(durations)

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)


# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    
    # model
    m = Model()
    
    # constraints
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))

    # Objective
    m.minimize(max(tardiness))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())","import pandas as pd
import numpy as np
import plotly.express as px
from cpmpy import *
import random
import math
from decimal import Decimal

# Define the problem parameters
num_jobs = 5
num_machines = 5
max_duration = 20
due_date_allowance = 1.3
job_durations = [random.expovariate(1) for _ in range(num_jobs)]
total_durations = sum(job_durations for _ in range(num_jobs))
print(""Total duration:"", total_durations)
job_dependencies = [[0, 1] for _ in range(num_jobs)]
print(""Job dependencies:"", job_dependencies)

# Initialize the queue
job_queue = [i for i in range(num_jobs)]
print(""Job queue:"", job_queue)

# Initialize the completion list
completion_queue = []

# Initialize the tardiness list
tardiness = []

# Solve the problem
for _ in range(num_durations):
    job_id = random.choice(num_jobs)
    job_durations[job_id] = random.expovariate(1)
    total_durations -= job_durations[job_id]
    job_queue.append(job_id)
    while len(job_queue) > 0:
        job_id = job_queue.pop(0)
        job_queue.extend([i for i in range(num_machines) if i not in completion_queue])
        if job_durations[job_id] <= total_durations:
            break
        else:
            job_durations[job_id] = random.expovariate(1)

    if job_durations[job_id] <= total_durations:
        completion_queue.append(job_id)
    else:
        tardiness.append(job_durations[job_id])

# Print the results
print(""Maximum tardiness:"", max(tardiness))

# Visualize the results
fig, ax = px.line(x=range(len(tardiness)), y=tardiness, label=""Tardiness"")
ax.set_xlabel(""Job ID"")
ax.set_ylabel(""Tardiness"")
ax.set_title(""Tardiness vs Job ID"")
ax.legend()
fig.show()

# Print the results
print(""Solutions:"", solutions)
","import random
import cpmpy as cp
import numpy as np

# Problem parameters
num_jobs = 5
num_machines = 5
max_duration = 20
due_date_allowance = 1.3

# Generate random routes and durations
durations = np.zeros((num_jobs, num_machines), dtype=int)
routes = np.zeros((num_jobs, num_machines), dtype=int)

for job in range(num_jobs):
    routes[job] = np.random.permutation(num_machines)
    durations[job] = np.random.randint(1, max_duration+1, size=num_machines)

# Calculate due dates
total_processing_times = durations.sum(axis=1)
due_dates = (total_processing_times * due_date_allowance).astype(int)

# Variables
start_times = cp.intvar(0, sum(total_processing_times), shape=(num_jobs, num_machines))
end_times = cp.intvar(0, sum(total_processing_times), shape=(num_jobs, num_machines))
tardiness = cp.intvar(0, sum(total_processing_times), shape=num_jobs)

# Constraints
constraints = []

for job in range(num_jobs):
    for i in range(num_machines):
        machine = routes[job, i]
        duration = durations[job, i]

        # End time for each operation
        constraints.append(end_times[job, i] == start_times[job, i] + duration)

        # Precedence constraints within the same job
        if i > 0:
            constraints.append(start_times[job, i] >= end_times[job, i-1])

        # No overlap constraints between jobs on the same machine
        for other_job in range(num_jobs):
            if other_job != job:
                other_machine_index = np.where(routes[other_job] == machine)[0][0]
                constraints.append(cp.all([start_times[job, i] >= end_times[other_job, other_machine_index]] + 
                                          [start_times[other_job, other_machine_index] >= end_times[job, i]]))

    # Tardiness calculation
    constraints.append(tardiness[job] >= end_times[job, -1] - due_dates[job])

# Objective: Minimize maximum tardiness
objective = cp.max(tardiness)

# Model
model = cp.Model(constraints)
model.minimize(objective)

# Solve
if model.solve():
    print(""Solution found!"")
    print(""Start times:"")
    print(start_times.value())
    print(""End times:"")
    print(end_times.value())
    print(""Tardiness:"")
    print(tardiness.value())
    print(""Maximum tardiness:"", objective.value())
else:
    print(""No solution found."")
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 5
number_of_machines = 5
maximum_duration = 20
due_date_allowance = 1.3

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(map(sum, durations))

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (due_date_allowance * np.sum(durations, axis=1)).astype(int)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)

# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))

    # Objective
    m.minimize(max(tardiness))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start, end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Maximum Tardiness:"", max(tardiness.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 5  
number_of_machines = 5  
maximum_duration = 20
due_date_allowance = 1.3

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(map(sum, durations))

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)


# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()

    # constraints
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))
    
    # Objective
    m.minimize(max(tardiness))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
",Valid,Valid,Valid,Invalid: name 'job_durations' is not defined
7,"Create job shop scheduling model with 6 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total weighted tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Job two and four will have task durations in minutes. Other jobs will have task durations in seconds","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 6  
number_of_machines = 6  
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50
weight_choices = [1, 2, 4]
probabilities = [0.2, 0.6, 0.2]

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    durations = []
    for i in range(number_of_jobs):
        if(i==1 or i==3):
            durations.append([random.randint(1, maximum_duration)*60 for _ in  range(number_of_machines)]) 
        else:
            durations.append([random.randint(1, maximum_duration) for _ in  range(number_of_machines)])
        
    return durations

def get_last_time(durations):
    return sum(durations)

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]

def get_weights(weight_choices, probabilities, number_of_jobs):
    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
weights = get_weights(weight_choices, probabilities, number_of_jobs)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)


# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m + (start[:, 0] >= release_times)
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))

    # Objective
    m.minimize(sum(weights*tardiness))


    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Total Weighted Tardiness:"", sum(weights*tardiness.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())","# imports
import pandas as pd
import numpy as np
import plotly.express as px
from cpmpy import *
import random

# settings
random.seed(1)
number_of_jobs = 6
number_of_machines = 6
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50
weight_choices = [1, 2, 4]
probabilities = [0.2, 0.6, 0.2]

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    durations = []
    for i in range(number_of_jobs):
        if(i==1 or i==3):
            durations.append([random.randint(1, maximum_duration)*60 for _ in  range(number_of_machines)])
        else:
            durations.append([random.randint(1, maximum_duration) for _ in  range(number_of_machines)])
    return durations

def get_last_time(durations):
    return sum(durations)

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def calculate_weights(number_of_jobs):
    return [random.choice(weight_choices) for _ in range(number_of_jobs)]

def calculate_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [sum(random.choices(durations, k)) for k in  range(number_of_machines)]

def calculate_last_time(durations):
    return  max(durations)

def calculate_total_weight(number_of_jobs, maximum_duration):
    return sum([calculate_weights(number_of_jobs)(i, maximum_duration) for i in range(1, number_of_jobs+1)])

def  print_solutions(number_of_jobs, maximum_duration):
    print(""solutions:"")
    print(""---------------------"")
    print(""last time:"", get_last_time(get_durations(number_of_jobs, number_of_machines, maximum_duration)))
    print(""total weight:"", calculate_total_weight(number_of_jobs, maximum_duration))
    print(""---------------------"")

# solve the problem
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
print_solutions(number_of_jobs, maximum_duration)

# visualise the solution
figure = px.line(x=range(1, len(durations)+1), y=durations, label=""durations"")
figure.update_layout(title=""Visualisation of a Job Shop"", xaxis_title=""Job Index"", yaxis_title=""Time"")
figure.show()","import random
import numpy as np
import cpmpy as cp

# Constants
num_jobs = 6
num_machines = 6
max_duration = 20
due_date_allowance = 1.3

# Generate random routes and durations
random.seed(0)
routes = [random.sample(range(num_machines), k=num_machines) for _ in range(num_jobs)]
durations = []
for i in range(num_jobs):
    if i in [1, 3]:  # Job 2 and 4 (index 1 and 3) have durations in minutes
        durations.append([random.randint(1, max_duration) * 60 for _ in range(num_machines)])
    else:  # Other jobs have durations in seconds
        durations.append([random.randint(1, max_duration) for _ in range(num_machines)])

# Calculate due dates and release times
release_times = [random.randint(0, 50) for _ in range(num_jobs)]
total_processing_times = [sum(durations[i]) for i in range(num_jobs)]
due_dates = [int(total_processing_times[i] * due_date_allowance) for i in range(num_jobs)]

# Generate random weights
weights_distribution = [1, 2, 4]
weights = np.random.choice(weights_distribution, num_jobs, p=[0.2, 0.6, 0.2])

# Variables
start_times = [[cp.intvar(0, sum(total_processing_times)) for _ in range(num_machines)] for _ in range(num_jobs)]
end_times = [[start_times[j][i] + durations[j][i] for i in range(num_machines)] for j in range(num_jobs)]
completion_times = [end_times[j][-1] for j in range(num_jobs)]

# Constraints
model = cp.Model()

# Enforce machine constraints
for machine in range(num_machines):
    machine_intervals = []
    for job in range(num_jobs):
        for op in range(num_machines):
            if routes[job][op] == machine:
                machine_intervals.append(cp.interval_var(start=start_times[job][op], end=end_times[job][op], length=durations[job][op]))
    model += cp.no_overlap(machine_intervals)

# Enforce job order constraints
for job in range(num_jobs):
    for op in range(1, num_machines):
        model += end_times[job][op-1] <= start_times[job][op]

# Enforce release time constraints
for job in range(num_jobs):
    model += start_times[job][0] >= release_times[job]

# Objective function: minimize total weighted tardiness
tardiness = [cp.maximum(completion_times[job] - due_dates[job], 0) for job in range(num_jobs)]
weighted_tardiness = cp.sum([weights[job] * tardiness[job] for job in range(num_jobs)])
model.minimize(weighted_tardiness)

# Solve the model
if model.solve():
    print(""Optimal weighted tardiness:"", weighted_tardiness.value())
    for job in range(num_jobs):
        for op in range(num_machines):
            print(f""Job {job + 1}, Operation {op + 1} on Machine {routes[job][op]}: Start at {start_times[job][op].value()}, End at {end_times[job][op].value()}"")
else:
    print(""No solution found"")
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 6  
number_of_machines = 6  
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50
weight_choices = [1, 2, 4]
probabilities = [0.2, 0.6, 0.2]

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    durations = []
    for job in range(number_of_jobs):
        if job == 1 or job == 3:  # Job 2 and 4 (index 1 and 3) have durations in minutes
            durations.append([random.randint(1, maximum_duration) * 60 for _ in range(number_of_machines)])
        else:
            durations.append([random.randint(1, maximum_duration) for _ in range(number_of_machines)])
    return durations

def get_last_time(durations):
    return sum(max(durations, key=sum))

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance * np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0, maximum_release_time) for _ in range(number_of_jobs)]

def get_weights(weight_choices, probabilities, number_of_jobs):
    return random.choices(weight_choices, weights=probabilities, k=number_of_jobs)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
weights = get_weights(weight_choices, probabilities, number_of_jobs)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)

# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m += (start[:, 0] >= release_times)
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks - 1] - due_dates[j], 0]))

    # Objective: minimize total weighted tardiness
    m.minimize(sum(tardiness[j] * weights[j] for j in range(number_of_jobs)))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start, end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Total Weighted Tardiness:"", sum(tardiness.value() * weights))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 6  
number_of_machines = 6  
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50
weight_choices = [1, 2, 4]
probabilities = [0.2, 0.6, 0.2]

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    durations = []
    for i in range(number_of_jobs):
        if(i==1 or i==3):
            durations.append([random.randint(1, maximum_duration)*60 for _ in  range(number_of_machines)]) 
        else:
            durations.append([random.randint(1, maximum_duration) for _ in  range(number_of_machines)])
    return durations

def get_last_time(durations):
    return sum(map(sum, durations))

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]

def get_weights(weight_choices, probabilities, number_of_jobs):
    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
weights = get_weights(weight_choices, probabilities, number_of_jobs)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)

# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m += (start[:, 0] >= release_times)
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))
        
    # The first task related to each job should be completed before the completion of any job
    for i in range(number_of_jobs):
        m += (end[:, 0] <= end[i, 5])

    # Objective
    m.minimize(sum(weights*tardiness))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Total Weighted Tardiness:"", sum(weights*tardiness.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
",Invalid: name 'num_machines' is not defined,Invalid: max() got an unexpected keyword argument 'key',Valid,Invalid: name 'get_last_time' is not defined
8,"Create job shop scheduling model with 6 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total flow time (completion time - release time). Maximum duration is 20. Note: The first task related to each job shoub be completed before the completion of any job.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 6  
number_of_machines = 6  
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50
weight_choices = [1, 2, 4]
probabilities = [0.2, 0.6, 0.2]

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(durations)

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]

def get_weights(weight_choices, probabilities, number_of_jobs):
    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
weights = get_weights(weight_choices, probabilities, number_of_jobs)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)


# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m + (start[:, 0] >= release_times)
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))
        
    # The first task related to each job shoub be completed before the completion of any job
    for i in range(number_of_jobs):
        m += (end[:, 0] <= end[i, 5])

    # Objective
    m.minimize(sum(end[:, number_of_tasks -1] - release_times))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Total Flowtime:"", sum(end[:, number_of_machines-1].value() - release_times))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())","import pandas as pd
import numpy as np
import math
from random import randint
import copy
from heapq import heapify, heappop
from datetime import datetime
import pandas as pd

#function to calculate completion time
def completion_time(start_time, finish_time):
    return finish_time - start_time

#function to calculate due date
def due_date(lead_time):
    return lead_time * 1.3

#function to calculate flow time
def flow_time(start_times, finish_times):
    return [completion_time(start_times[i], finish_times[i]) for i in range(len(start_times))]

#function to generate random start and finish times
def random_start_end(n):
    return [datetime(2023, 1, 1) + timedelta(hours=randint(0, 24) for _ in range(n)]

#function to generate random durations
def random_duration(n):
    return [randint(1, 20) for _ in range(n)]

#function to generate random weights
def random_weights(n):
    return [randint(1, 4) for _ in range(n)]

#function to generate random lead times
def random_lead_times(n):
    return [due_date(r) for r in random_start_end(n)]

#function to generate random tasks
def random_tasks(n, m, l):
    return [{""id"": i+1, ""weight"": w, ""lead_time"": l, ""finish_time"": l + random_duration(w), ""start_time"": random_start_end(m)[i][""time""] + datetime(hours=randint(0, 24)} for i in range(m)]

#setting parameters
m=6
n=6
max_time=20

#creating the model
model = {""tasks"":random_tasks(m,n,l)}
model[""parameters""] = {""m"":m,""n"":n,""l"":max_time}
model[""finish_times""] = completion_time(model[""parameters""][""start_time""],model[""parameters""][""finish_time""])
print(model)
```","import random
from cpmpy import *
import numpy as np

# Constants
num_jobs = 6
num_machines = 6
max_duration = 20
due_date_allowance = 1.3

# Random durations for each job's operations
durations = [[random.randint(1, max_duration) for _ in range(num_machines)] for _ in range(num_jobs)]

# Random routes for each job: each job will have a unique sequence of machines
routes = [random.sample(range(num_machines), num_machines) for _ in range(num_jobs)]

# Release times for each job
release_times = [random.randint(0, 50) for _ in range(num_jobs)]

# Due dates based on total processing time and due date allowance
due_dates = [int(sum(durations[job][i] for i in range(num_machines)) * due_date_allowance) for job in range(num_jobs)]

# Job weights following the given distribution
weights = [random.choices([1, 2, 4], [0.2, 0.6, 0.2])[0] for _ in range(num_jobs)]

# Variables
start_times = [[intvar(0, sum(durations[job]), name=f'start_{job}_{op}') for op in range(num_machines)] for job in range(num_jobs)]
end_times = [[intvar(0, sum(durations[job]), name=f'end_{job}_{op}') for op in range(num_machines)] for job in range(num_jobs)]
completion_times = [intvar(0, sum(durations[job]), name=f'completion_{job}') for job in range(num_jobs)]

# Model
model = Model()

# Constraints for job routes and durations
for job in range(num_jobs):
    for idx, machine in enumerate(routes[job]):
        if idx == 0:
            model += (start_times[job][idx] == release_times[job])
        else:
            model += (start_times[job][idx] >= end_times[job][idx - 1])
        model += (end_times[job][idx] == start_times[job][idx] + durations[job][machine])

# Constraints for machine availability (no overlap)
for machine in range(num_machines):
    for job1 in range(num_jobs):
        for job2 in range(job1 + 1, num_jobs):
            for op1 in range(num_machines):
                for op2 in range(num_machines):
                    if routes[job1][op1] == routes[job2][op2]:
                        model += (end_times[job1][op1] <= start_times[job2][op2]) | (end_times[job2][op2] <= start_times[job1][op1])

# Completion times
for job in range(num_jobs):
    model += (completion_times[job] == end_times[job][-1])

# Objective: Minimize total flow time
flow_times = [completion_times[job] - release_times[job] for job in range(num_jobs)]
model.minimize(sum(flow_times))

# Solve model
solver = CPM_ortools(model)
if solver.solve():
    for job in range(num_jobs):
        print(f""Job {job} completion time: {completion_times[job].value()}"")
else:
    print(""No solution found"")
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 6  
number_of_machines = 6  
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50
weight_choices = [1, 2, 4]
probabilities = [0.2, 0.6, 0.2]

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(sum(durations, []))

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]

def get_weights(weight_choices, probabilities, number_of_jobs):
    return random.choices(weight_choices, weights=probabilities, k=number_of_jobs)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
weights = get_weights(weight_choices, probabilities, number_of_jobs)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)

# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m += (start[:, 0] >= release_times)
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks - 1] - due_dates[j], 0]))
        
    # The first task related to each job should be completed before the completion of any job
    for j in range(number_of_jobs):
        for i in range(number_of_jobs):
            if i != j:
                m += (end[j, 0] <= end[i, number_of_tasks - 1])

    # Objective
    m.minimize(sum(end[:, number_of_tasks - 1] - release_times))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start, end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Total Flowtime:"", sum(end[:, number_of_machines-1].value() - release_times))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 6  
number_of_machines = 6  
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50
weight_choices = [1, 2, 4]
probabilities = [0.2, 0.6, 0.2]

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(sum(durations, []))

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]

def get_weights(weight_choices, probabilities, number_of_jobs):
    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
weights = get_weights(weight_choices, probabilities, number_of_jobs)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)

# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m += (start[:, 0] >= release_times)
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))
        
    # The first task related to each job should be completed before the completion of any job
    for j in range(number_of_jobs):
        m += [end[:, 0] <= end[j, number_of_tasks - 1]]

    # Objective
    m.minimize(sum(end[:, number_of_tasks -1] - release_times))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Total Flowtime:"", sum(end[:, number_of_machines-1].value() - release_times))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
",Invalid: name 'num_machines' is not defined,Invalid: sum() takes 1 positional argument but 2 were given,Invalid: sum() takes 1 positional argument but 2 were given,"Invalid: closing parenthesis ']' does not match opening parenthesis '(' (<string>, line 24)"
9,"Create job shop scheduling model with 7 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total weighted flowtime. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Job two has to be completed first.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 7  
number_of_machines = 6  
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50
weight_choices = [1, 2, 4]
probabilities = [0.2, 0.6, 0.2]

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(durations)

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]

def get_weights(weight_choices, probabilities, number_of_jobs):
    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
weights = get_weights(weight_choices, probabilities, number_of_jobs)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)


# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m + (start[:, 0] >= release_times)
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))
        
    # Job two has to be completed first
    for i in range(number_of_jobs):
        if i != 1:
            m += (end[i, 5] > end[1, 5])

    # Objective
    m.minimize(sum(weights*(end[:, number_of_tasks -1] - release_times)))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Total Weighted Flowtime:"", sum(weights*(end[:, number_of_machines-1].value() - release_times)))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())","import pandas as pd
import numpy as np
import plotly.express as px
from cpmpy import *
import random
import math
from decimal import Decimal

# Define the problem parameters
num_jobs = 7
num_machines = 6
max_duration = 20
delta = 1.3
release_values = [0, 10, 20, 30, 40, 50]
weights = [1, 2, 4]
due_dates = [i * max_duration for i in release_values]
duration = [random.expovariate(1 / d) for d in due_dates]
travel_times = [0] * num_machines
end_times = [sum(t) for t in travel_times]
wait_times = [0] * num_jobs
total_weights = [0] * num_jobs
visuals = []
solutions = []
for i in range(num_jobs):
    visuals.append(plotly.figure(figsize=(10, 6))
    wait_times[i] = random.uniform(0, max(end_times[i]))
    solutions.append(visuals[-i])
    total_weights[i] = weights[i] * duration[i]
    wait_times[i].update_state(wait_times[i], end_times[i])
    visuals[-i].update_traces(wait_times[i])
    visuals[-i].show()
    print('Job {}:{}'.format(i, solutions[i]))
print('Total weights:', total_weights)
# Print the results
for i, v in enumerate(visuals):
    print('Visual {}:'.format(i), v)
print('Solutions:', solutions)
print('Wait times:', wait_times)
# Visualize the results
# plt.figure(figsize=(10,6))
# for i,v in enumerate(visuals):
#     v.update_traces(wait_times[i])
#     v.show()
# plt.show()","import random
import cpmpy as cp
import numpy as np

# Constants
num_jobs = 7
num_machines = 6
max_duration = 20
due_date_allowance = 1.3

# Generate random durations for operations
durations = [[random.randint(1, max_duration) for _ in range(num_machines)] for _ in range(num_jobs)]

# Generate random routes for each job
routes = [random.sample(range(num_machines), random.randint(1, num_machines)) for _ in range(num_jobs)]

# Calculate total processing time and due dates
total_processing_times = [sum(durations[job][machine] for machine in routes[job]) for job in range(num_jobs)]
due_dates = [int(total_processing_times[job] * due_date_allowance) for job in range(num_jobs)]

# Generate random release times
release_times = [random.randint(0, 50) for _ in range(num_jobs)]

# Generate random weights
weights = [random.choices([1, 2, 4], weights=[0.2, 0.6, 0.2])[0] for _ in range(num_jobs)]

# Variables
start_times = [[cp.intvar(0, sum(total_processing_times)) for _ in range(num_machines)] for _ in range(num_jobs)]
end_times = [[cp.intvar(0, sum(total_processing_times)) for _ in range(num_machines)] for _ in range(num_jobs)]
job_end_times = [cp.intvar(0, sum(total_processing_times)) for _ in range(num_jobs)]

# Model
model = cp.Model()

# Constraints
for job in range(num_jobs):
    for i in range(len(routes[job])):
        machine = routes[job][i]
        if i == 0:
            # First operation of the job
            model += (start_times[job][machine] >= release_times[job])
        else:
            # Ensure operations follow each other
            prev_machine = routes[job][i - 1]
            model += (start_times[job][machine] >= end_times[job][prev_machine])

        # Duration constraint
        model += (end_times[job][machine] == start_times[job][machine] + durations[job][machine])

    # Ensure job end time is the end time of the last operation
    last_machine = routes[job][-1]
    model += (job_end_times[job] == end_times[job][last_machine])

# Machine capacity constraints
for machine in range(num_machines):
    for job1 in range(num_jobs):
        for job2 in range(job1 + 1, num_jobs):
            if machine in routes[job1] and machine in routes[job2]:
                op1 = routes[job1].index(machine)
                op2 = routes[job2].index(machine)
                model += (start_times[job1][machine] >= end_times[job2][machine]) | (start_times[job2][machine] >= end_times[job1][machine])

# Job two must be completed first
for job in range(num_jobs):
    if job != 1:
        model += (job_end_times[1] <= job_end_times[job])

# Objective: Minimize total weighted flowtime
total_weighted_flowtime = cp.sum([weights[job] * (job_end_times[job] - release_times[job]) for job in range(num_jobs)])
model.minimize(total_weighted_flowtime)

# Solve model
if model.solve():
    print(""Solution found:"")
    for job in range(num_jobs):
        print(f""Job {job + 1}:"")
        for machine in routes[job]:
            print(f""  Machine {machine + 1}: Start = {start_times[job][machine].value()}, End = {end_times[job][machine].value()}"")
else:
    print(""No solution found."")
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 7  
number_of_machines = 6  
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50
weight_choices = [1, 2, 4]
probabilities = [0.2, 0.6, 0.2]

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(sum(row) for row in durations)

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]

def get_weights(weight_choices, probabilities, number_of_jobs):
    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
weights = get_weights(weight_choices, probabilities, number_of_jobs)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)

# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m += (start[:, 0] >= release_times)
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [(end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks - 1] - due_dates[j], 0]))
        
    # Job two has to be completed first
    for i in range(number_of_jobs):
        if i != 1:
            m += (end[i, number_of_tasks - 1] > end[1, number_of_tasks - 1])

    # Objective: Minimize total weighted flowtime
    m.minimize(sum(weights[j] * (end[j, number_of_tasks - 1] - release_times[j]) for j in range(number_of_jobs)))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start, end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Total Weighted Flowtime:"", sum(weights[j] * (end[j, number_of_machines - 1].value() - release_times[j]) for j in range(number_of_jobs)))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 7  
number_of_machines = 6  
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50
weight_choices = [1, 2, 4]
probabilities = [0.2, 0.6, 0.2]

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(map(sum, durations))

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]

def get_weights(weight_choices, probabilities, number_of_jobs):
    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
weights = get_weights(weight_choices, probabilities, number_of_jobs)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)

# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m += (start[:, 0] >= release_times)
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))
        
    # Job two has to be completed first
    for j in range(number_of_jobs):
        if j != 1:
            m += (end[1, -1] <= end[j, -1])

    # Objective
    m.minimize(sum(weights*(end[:, number_of_tasks -1] - release_times)))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Total Weighted Flowtime:"", sum(weights*(end[:, number_of_machines-1].value() - release_times)))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
",Invalid: name 'num_machines' is not defined,Invalid: name 'weights' is not defined,Valid,"Invalid: '(' was never closed (<string>, line 25)"
10,"Create job shop scheduling model with 6 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total flow time (completion time - release time). Maximum duration is 20. After solving the problem, solutions will be printed and visualised.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 6  
number_of_machines = 6  
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50
weight_choices = [1, 2, 4]
probabilities = [0.2, 0.6, 0.2]

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(durations)

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]

def get_weights(weight_choices, probabilities, number_of_jobs):
    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
weights = get_weights(weight_choices, probabilities, number_of_jobs)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)


# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m + (start[:, 0] >= release_times)
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))

    # Objective
    m.minimize(sum(end[:, number_of_tasks -1] - release_times))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Total Flowtime:"", sum(end[:, number_of_machines-1].value() - release_times))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())","# imports
import pandas as pd
import numpy as np
import plotly.express as px
from cpmpy import *
import random

# settings
random.seed(1)
number_of_jobs = 6
number_of_machines = 6
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50
weight_choices = [1, 2, 4]
probabilities = [0.2, 0.6, 0.2]

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    durations = []
    for i in range(number_of_jobs):
        if maximum_duration == 20:
            durations.append([random.randint(1, 20) for _ in  range(number_of_machines)])
        else:
            durations.append([random.randint(1, 50) for _ in  range(number_of_machines)])
    return durations

def get_last_time(durations):
    return sum(durations)

def get_simulated_system(number_of_jobs, number_of_machines, maximum_duration, due_date_allowance, maximum_release_time, weight_choices, probabilities):
    durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
    last_time = get_last_time(durations)
    simulated_system = []
    for i in range(number_of_jobs):
        time = 0
        state = 0
        for j in range(len(durations)):
            if durations[j] <= time:
                state = j
                break
            time += durations[j]
        simulated_system.append([last_time, time - last_time, weight_choices[state], probabilities[state]])
    return simulated_system

# simulations
results = []
for i in range(1000):
    system = get_simulated_system(number_of_jobs, number_of_machines, maximum_duration, due_date_allowance, maximum_release_time, weight_choices, probabilities)
    results.append(system)

# printing and visualiztion
final_results = []
for a, b, c, d in results:
    final_results.append([a, b, c, d])
df = pd.DataFrame(final_results)
print(df)

# visualiztion
fig, ax = px.line(x=[i for i, _ in enumerate(df)], y=[i for i, _ in enumerate(df)], labels=[""Completion time"", ""Release time"", ""Weight"", ""Probability""])
ax.set_title(""Simulation Results"")
ax.set_xlabel(""Time"")
ax.set_ylabel(""Value"")
ax.legend(loc=""upper right"")
fig.show()","import numpy as np
from cpmpy import *
from cpmpy.solvers import CPM_ortools
import matplotlib.pyplot as plt

# Constants
num_jobs = 6
num_machines = 6
max_duration = 20

# Random seed for reproducibility
np.random.seed(42)

# Generating random durations for each job's operations
durations = {j: [np.random.randint(1, max_duration+1) for _ in range(num_machines)] for j in range(num_jobs)}

# Generating random routes for each job
routes = {j: np.random.permutation(num_machines).tolist() for j in range(num_jobs)}

# Calculating total processing time for each job
total_processing_time = {j: sum(durations[j][i] for i in routes[j]) for j in range(num_jobs)}

# Calculating due dates with allowance
due_date_allowance = 1.3
due_dates = {j: int(total_processing_time[j] * due_date_allowance) for j in range(num_jobs)}

# Generating random release times
release_times = {j: np.random.randint(0, 51) for j in range(num_jobs)}

# Generating job weights
weights = {j: np.random.choice([1, 2, 4], p=[0.2, 0.6, 0.2]) for j in range(num_jobs)}

# Create the CPMpy model
model = Model()

# Variables
start_times = {j: {o: intvar(0, sum(max_duration for _ in range(num_machines))) for o in range(num_machines)} for j in range(num_jobs)}
end_times = {j: {o: intvar(0, sum(max_duration for _ in range(num_machines))) for o in range(num_machines)} for j in range(num_jobs)}

# Constraints
for j in range(num_jobs):
    for o in range(num_machines):
        # Operation constraints
        if o == 0:
            model += [start_times[j][o] >= release_times[j]]  # Release time constraint for first operation
        else:
            model += [start_times[j][o] >= end_times[j][o-1]]  # Operations sequence constraint
        
        end_op = routes[j][o]
        model += [end_times[j][o] == start_times[j][o] + durations[j][end_op]]  # Duration constraint

        # Machine constraints
        for j2 in range(num_jobs):
            if j != j2:
                for o2 in range(num_machines):
                    if routes[j][o] == routes[j2][o2]:  # Same machine constraint
                        model += [start_times[j][o] >= end_times[j2][o2]] | [start_times[j2][o2] >= end_times[j][o]]

# Objective: Minimize total flow time
total_flow_time = sum(weights[j] * (end_times[j][num_machines-1] - release_times[j]) for j in range(num_jobs))
model.minimize(total_flow_time)

# Solve the problem
solver = CPM_ortools(model)
if solver.solve():
    print(""Solution found:"")
    for j in range(num_jobs):
        for o in range(num_machines):
            print(f""Job {j}, Operation {o}: Start {start_times[j][o].value()}, End {end_times[j][o].value()}"")

    # Visualization
    fig, ax = plt.subplots(figsize=(10, 6))
    for j in range(num_jobs):
        for o in range(num_machines):
            start = start_times[j][o].value()
            end = end_times[j][o].value()
            ax.barh(j, end - start, left=start, edgecolor='black', align='center')
    ax.set_yticks(range(num_jobs))
    ax.set_yticklabels([f""Job {j}"" for j in range(num_jobs)])
    ax.set_xlabel(""Time"")
    ax.set_title(""Job Shop Scheduling Gantt Chart"")
    plt.show()
else:
    print(""No solution found."")
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 6  
number_of_machines = 6  
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50
weight_choices = [1, 2, 4]
probabilities = [0.2, 0.6, 0.2]

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(map(sum, durations))

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number {i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]

def get_weights(weight_choices, probabilities, number_of_jobs):
    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
weights = get_weights(weight_choices, probabilities, number_of_jobs)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)


# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m += (start[:, 0] >= release_times)
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))

    # Objective
    m.minimize(sum(end[:, number_of_tasks -1] - release_times))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Total Flowtime:"", sum(end[:, number_of_machines-1].value() - release_times))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 6  
number_of_machines = 6  
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50
weight_choices = [1, 2, 4]
probabilities = [0.2, 0.6, 0.2]

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum([sum(job) for job in durations])

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0, maximum_release_time) for _ in range(number_of_jobs)]

def get_weights(weight_choices, probabilities, number_of_jobs):
    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
weights = get_weights(weight_choices, probabilities, number_of_jobs)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)

# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m += (start[:, 0] >= release_times)
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))
    
    # Objective
    m.minimize(sum(end[:, number_of_tasks -1] - release_times))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start, end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Total Flowtime:"", sum(end[:, number_of_machines-1].value() - release_times))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
",Invalid: name 'num_machines' is not defined,Valid,Valid,Invalid: name 'get_durations' is not defined
11,"Create job shop scheduling model with 4 jobs and 5 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. The objective function is maximum tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Job two has to be completed first","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 4  
number_of_machines = 5  
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(durations)

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)


# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m + (start[:, 0] >= release_times)
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))
        
    # Job two has to be completed first
    for i in range(number_of_jobs):
        if i != 1:
            m += (end[i, 4] > end[1, 4])

    # Objective
    m.minimize(max(tardiness))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())",Output:,"import numpy as np
from cpmpy import *
from cpmpy.solvers import CPM_ortools

# Constants
num_jobs = 4
num_machines = 5
max_duration = 20
due_date_allowance = 1.3

# Generate random routes and durations
np.random.seed(0)  # For reproducibility
routes = [np.random.choice(num_machines, np.random.randint(1, num_machines + 1), replace=False) for _ in range(num_jobs)]
durations = [np.random.randint(1, max_duration + 1, len(routes[j])) for j in range(num_jobs)]

# Calculate due dates based on total processing times and allowance
total_processing_times = [sum(durations[j]) for j in range(num_jobs)]
due_dates = [int(total_processing_times[j] * due_date_allowance) for j in range(num_jobs)]

# Random release times
release_times = np.random.randint(0, 51, num_jobs)

# Variables
start_times = [[intvar(0, sum(total_processing_times), name=f'start_{j}_{o}') for o in range(len(routes[j]))] for j in range(num_jobs)]
end_times = [[intvar(0, sum(total_processing_times), name=f'end_{j}_{o}') for o in range(len(routes[j]))] for j in range(num_jobs)]
job_end_times = [intvar(0, sum(total_processing_times), name=f'job_end_{j}') for j in range(num_jobs)]
tardiness = [intvar(0, sum(total_processing_times), name=f'tardiness_{j}') for j in range(num_jobs)]
max_tardiness = intvar(0, sum(total_processing_times), name='max_tardiness')

# Constraints
model = Model()

for j in range(num_jobs):
    for o in range(len(routes[j])):
        # Job operation duration constraints
        model += (end_times[j][o] == start_times[j][o] + durations[j][o])
        
        # Release time constraint
        if o == 0:
            model += (start_times[j][o] >= release_times[j])
        
        # Precedence constraints within a job
        if o > 0:
            model += (start_times[j][o] >= end_times[j][o-1])

        # Machine constraints: no overlapping on the same machine
        for j2 in range(num_jobs):
            for o2 in range(len(routes[j2])):
                if j != j2 and routes[j][o] == routes[j2][o2]:
                    model += (start_times[j][o] >= end_times[j2][o2]) | (start_times[j2][o2] >= end_times[j][o])
    
    # Calculate end time of the job
    model += (job_end_times[j] == end_times[j][-1])

# Tardiness and objective function
for j in range(num_jobs):
    model += (tardiness[j] == job_end_times[j] - due_dates[j])
model += (max_tardiness == max(tardiness))

# Additional constraint: Job two has to be completed first
for j in range(num_jobs):
    if j != 1:
        model += (job_end_times[1] <= job_end_times[j])

# Objective
model.minimize(max_tardiness)

# Solve the model
solver = CPM_ortools(model)
if solver.solve():
    for j in range(num_jobs):
        print(f""Job {j}:"")
        for o in range(len(routes[j])):
            print(f""  Operation {o} on Machine {routes[j][o]}: Start = {start_times[j][o].value()}, End = {end_times[j][o].value()}"")
        print(f""  Job End Time: {job_end_times[j].value()}, Due Date: {due_dates[j]}, Tardiness: {tardiness[j].value()}"")
    print(f""Maximum Tardiness: {max_tardiness.value()}"")
else:
    print(""No solution found"")
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 4  
number_of_machines = 5  
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(map(sum, durations))

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines + 1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (due_date_allowance * np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0, maximum_release_time) for _ in range(number_of_jobs)]

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)

# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # Tardiness of each job

    # model
    m = Model()
    
    # constraints
    m += (start[:, 0] >= release_times)
    m += (end == start + durations)  # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [(end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                  for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                  if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]

    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks - 1] - due_dates[j], 0]))

    # Job two has to be completed first
    for i in range(number_of_jobs):
        if i != 1:
            m += (end[i, number_of_tasks - 1] > end[1, number_of_tasks - 1])

    # Objective
    m.minimize(max(tardiness))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start, end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Maximum Tardiness:"", max(tardiness.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 4
number_of_machines = 5
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(map(sum, durations))

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance * np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0, maximum_release_time) for _ in range(number_of_jobs)]

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)

# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m += (start[:, 0] >= release_times)
    m += (end == start + durations)  # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks - 1] - due_dates[j], 0]))
    
    # Job two has to be completed first
    for j in range(number_of_jobs):
        if j != 1:
            m += (end[1, -1] <= end[j, -1])

    # Objective
    m.minimize(max(tardiness))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start, end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
",Invalid: name 'num_machines' is not defined,Valid,Valid,"Invalid: invalid syntax (<string>, line 1)"
12,"Create job shop scheduling model with 6 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total weighted flowtime. Maximum duration is 15. After solving the problem, solutions will be printed and visualised.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 6  
number_of_machines = 6  
maximum_duration = 15
due_date_allowance = 1.3
maximum_release_time = 50
weight_choices = [1, 2, 4]
probabilities = [0.2, 0.6, 0.2]

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(durations)

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]

def get_weights(weight_choices, probabilities, number_of_jobs):
    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
weights = get_weights(weight_choices, probabilities, number_of_jobs)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)


# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m + (start[:, 0] >= release_times)
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))

    # Objective
    m.minimize(sum(weights*(end[:, number_of_tasks -1] - release_times)))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Total Weighted Flowtime:"", sum(weights*(end[:, number_of_machines-1].value() - release_times)))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())","import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import math
from decimal import Decimal

# Define the problem parameters
num_jobs = 6
num_machines = 6
max_duration = 15
delta = 1.3
release_values = [0, 15, 30, 45, 60, 75]
weights = [1, 2, 4]
duration_allowance = [1, 2, 3]
release_durations = [random.uniform(0, 50, num_jobs) for _ in range(len(release_values))]
weights_durations = [random.choice(weights) for _ in range(len(duration_allowance)]
print_values = [random.choice(range(1, 51)) for _ in range(len(release_durations))]
print_values = [random.uniform(0, 50, len(print_values)) for _ in range(len(print_values)]
print_values = [random.uniform(0, 50, len(print_values)) for _ in range(len(print_values)]
print_values = [random.uniform(0, 50, len(print_values)) for _ in range(len(print_values)]
print_values = [random.uniform(0, 50, len(print_values)) for _ in range(len(print_values)]
print_values = [random.uniform(0, 50, len(print_values)) for _ in range(len(print_values)]

# Create the scheduler
scheduler = cpmpy.Schedule(num_machines, num_jobs, print_values, release_durations)
print(""Number of jobs:"", len(print_values))
print(""Number of machines:"", len(print_values[0]))
print(""Number of print values:"", len(print_values))
print(""Duration allowance:"", [str(x) for x in duration_allowance])
print(""Release values:"", [str(x) for x in release_durations])
print(""Print values:"", [str(x) for x in print_values])

# Define the objective function
def objective_function(schedule):
    flow_time = 0
    for i in range(len(print_values)):
        job_id = random.choice(1, len(print_values)+1)
        job_d = random.choice(1, len(print_values)+1)
        if schedule.resources[job_id-1]<random.choice(1, print_values[job_id-1]):
            flow_time += random.choice(1, print_values[job_id-1])
    return flow_time

# Set the objective function
scheduler.set_objective(objective_function)

# Solve the problem
print(""Solving..."")
scheduler.run()

# Print the results
print(""Best flow time:"", scheduler.result.flow_time)
print(""Best solution:"")
print(scheduler.result)

# Visualize the results
data = pd.DataFrame(scheduler.result)
fig = px.line(data.index, data.values)
fig.update_layout(title=""Job shop scheduling"", xaxis_title=""Time"", yaxis_title=""Flow time"")
fig.show()","from cpmpy import *
import numpy as np

# Define constants
num_jobs = 6
num_machines = 6
max_duration = 15
due_date_allowance = 1.3

# Random seed for reproducibility
np.random.seed(42)

# Generate random routes and durations for each job
durations = np.random.randint(1, max_duration + 1, size=(num_jobs, num_machines))
routes = [np.random.permutation(num_machines).tolist() for _ in range(num_jobs)]

# Calculate due dates
total_processing_time = durations.sum(axis=1)
due_dates = (total_processing_time * due_date_allowance).astype(int)

# Generate random release times
release_times = np.random.randint(0, 51, size=num_jobs)

# Generate random weights
weights = np.random.choice([1, 2, 4], size=num_jobs, p=[0.2, 0.6, 0.2])

# Variables
start_times = intvar(0, 1000, shape=(num_jobs, num_machines), name=""start_times"")
end_times = intvar(0, 1000, shape=(num_jobs, num_machines), name=""end_times"")
flows = intvar(0, 1000, shape=num_jobs, name=""flows"")

# Constraints
constraints = []

for j in range(num_jobs):
    for m in range(num_machines):
        op_idx = routes[j].index(m)
        if op_idx == 0:
            constraints += [start_times[j, m] >= release_times[j]]
        else:
            prev_machine = routes[j][op_idx - 1]
            constraints += [start_times[j, m] >= end_times[j, prev_machine]]
        constraints += [end_times[j, m] == start_times[j, m] + durations[j, m]]

for m in range(num_machines):
    for j1 in range(num_jobs):
        for j2 in range(j1 + 1, num_jobs):
            constraints += [
                (end_times[j1, m] <= start_times[j2, m]) | (end_times[j2, m] <= start_times[j1, m])
            ]

for j in range(num_jobs):
    constraints += [flows[j] == end_times[j, routes[j][-1]] - release_times[j]]

# Objective: Minimize total weighted flowtime
objective = sum(weights[j] * flows[j] for j in range(num_jobs))

# Model
model = Model(constraints, minimize=objective)

# Solve
solver = CPM_ortools(model)
if solver.solve():
    print(""Solution:"")
    for j in range(num_jobs):
        print(f""Job {j}: Start times: {start_times[j].value()}, End times: {end_times[j].value()}"")
        print(f""Flow time: {flows[j].value()}"")
else:
    print(""No solution found."")
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 6  
number_of_machines = 6  
maximum_duration = 15
due_date_allowance = 1.3
maximum_release_time = 50
weight_choices = [1, 2, 4]
probabilities = [0.2, 0.6, 0.2]

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(sum(durations, []))

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance * np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0, maximum_release_time) for _ in range(number_of_jobs)]

def get_weights(weight_choices, probabilities, number_of_jobs):
    return random.choices(weight_choices, weights=probabilities, k=number_of_jobs)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
weights = get_weights(weight_choices, probabilities, number_of_jobs)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)

# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    weighted_flowtime = intvar(0, last_time*max(weights), shape=(number_of_jobs), name=""weighted_flowtime"")  # weighted flowtime of each job

    # model
    m = Model()
    
    # constraints
    m += (start[:, 0] >= release_times)
    m += (end == start + durations)  # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]

    # calculate weighted flowtime
    for j in range(number_of_jobs):
        m += (weighted_flowtime[j] == weights[j] * (end[j, number_of_tasks - 1] - release_times[j]))

    # Objective
    m.minimize(sum(weighted_flowtime))

    return m, (start, end, weighted_flowtime)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(), 
                       'End': end.flatten(), 
                       'Machine': task_to_machine_mapping.flatten().astype(str), 
                       'Job': job_names.flatten(), 
                       'Name': full_names.flatten()})
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h', 
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start, end, weighted_flowtime)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Total Weighted Flowtime:"", sum(weighted_flowtime.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Weighted Flowtime:"", weighted_flowtime.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 6
number_of_machines = 6
maximum_duration = 15
due_date_allowance = 1.3
maximum_release_time = 50
weight_choices = [1, 2, 4]
probabilities = [0.2, 0.6, 0.2]

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(map(sum, durations))

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance * np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0, maximum_release_time) for _ in range(number_of_jobs)]

def get_weights(weight_choices, probabilities, number_of_jobs):
    return random.choices(weight_choices, weights=probabilities, k=number_of_jobs)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
weights = get_weights(weight_choices, probabilities, number_of_jobs)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)

# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()

    # constraints
    m += (start[:, 0] >= release_times)
    m += (end == start + durations)  # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs):
        for t in range(number_of_tasks):
            m += [(end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                  for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                  if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]

    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks - 1] - due_dates[j], 0]))

    # Objective
    m.minimize(sum(weights * (end[:, number_of_tasks - 1] - release_times)))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start, end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Total Weighted Flowtime:"", sum(weights * (end[:, number_of_machines - 1].value() - release_times)))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
",Invalid: name 'num_machines' is not defined,Invalid: sum() takes 1 positional argument but 2 were given,Valid,"Invalid: closing parenthesis ']' does not match opening parenthesis '(' (<string>, line 18)"
13,"Create job shop scheduling model with 4 jobs and 5 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. The objective function is maximum tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. The first task related to each job shoub be completed before the completion of any job","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 4  
number_of_machines = 5  
maximum_duration = 20
due_date_allowance = 1.3

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(durations)

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)


# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    
    # model
    m = Model()
    
    # constraints
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))
    
    # The first task related to each job shoub be completed before the completion of any job
    for i in range(number_of_jobs):
        m += (end[:, 0] <= end[i, 4])
        
    # Objective
    m.minimize(max(tardiness))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())","import pandas as pd
import numpy as np
import plotly.express as px
from cpmpy import *
import random
import math
from decimal import Decimal

# Define the problem parameters
num_jobs = 4
num_machines = 5
duration_allowance = 1.3
time_unit = 1
wait_time = 0
finish_time = 0
durations = []
start_times = []
end_times = []

# Calculate the total processing time for each job
for i in range(num_jobs):
    if i == 0 or i == 2:
        durations[i] = random.uniform(1, 20)
    else:
        durations[i] = random.uniform(1, 20)
    start_times[i] = random.uniform(1, 20)
    end_times[i] = start_times[i] + durations[i]
    wait_time.append(0)

# Calculate the total idle time
idle_time = durations[0] * time_unit

# Set the initial time
now = 0
end_times[0] = now
for i in range(1, num_jobs + 1):
    end_times[i] = now
    now += durations[i]

# Visualize the problem parameters
params = {
    'num_jobs': num_jobs,
    'num_machines': num_machines,
    'duration_allowance': duration_allowance,
    'time_unit': time_unit,
    'wait_time': wait_time,
    'finish_time': end_times,
    'durations': durations,
    'start_times': start_times,
    'end_times': end_times
}

# Create the scheduler
scheduler = CPYSchedule(params)

# Solve the problem
scheduler.solve()

# Print the solutions
print(""Number of jobs:"", len(params['start_times']))
print(""Number of machines:"", params['num_machines'])
print(""Duration allowance:"", params['duration_allowance'])
print(""Time unit:"", params['time_unit'])
print(""Wait time:"", params['wait_time'])
print(""Finish time:"", params['finish_time'])
print(""Durations:"", params['durations'])
print(""Start times:"", params['start_times'])
print(""End times:"", params['end_times'])

# Visualize the results
fig = px.line(params['start_times'], params['end_times'], label='Time')
fig.update_layout(title='Job Shop Scheduling', xaxis_title='Time', yaxis_title='Duration')
fig.show()

# Print the total idle time
print(""Total idle time:"", idle_time)","import random
import numpy as np
from cpmpy import *
from cpmpy.solvers import CPM_ortools

# Define constants
num_jobs = 4
num_machines = 5
max_duration = 20
due_date_allowance = 1.3

# Generate random job data
random.seed(0)
jobs = []
for j in range(num_jobs):
    num_operations = random.randint(1, num_machines)
    operations = []
    for o in range(num_operations):
        machine = random.randint(0, num_machines - 1)
        duration = random.randint(1, max_duration)
        operations.append((machine, duration))
    jobs.append(operations)

# Calculate due dates
total_processing_time = [sum(duration for machine, duration in job) for job in jobs]
due_dates = [int(due_date_allowance * tpt) for tpt in total_processing_time]

# Variables
start_times = [[intvar(0, sum(total_processing_time)) for operation in job] for job in jobs]
end_times = [[intvar(0, sum(total_processing_time)) for operation in job] for job in jobs]
max_tardiness = intvar(0, sum(total_processing_time))

# Constraints
constraints = []

# Each operation must start after the previous one has finished
for job in range(num_jobs):
    for op in range(1, len(jobs[job])):
        constraints.append(start_times[job][op] >= end_times[job][op - 1])

# Define end times
for job in range(num_jobs):
    for op in range(len(jobs[job])):
        machine, duration = jobs[job][op]
        constraints.append(end_times[job][op] == start_times[job][op] + duration)

# No two operations on the same machine at the same time
for machine in range(num_machines):
    machine_operations = [(job, op) for job in range(num_jobs) for op in range(len(jobs[job])) if jobs[job][op][0] == machine]
    for i in range(len(machine_operations)):
        for j in range(i + 1, len(machine_operations)):
            job1, op1 = machine_operations[i]
            job2, op2 = machine_operations[j]
            constraints.append(
                (end_times[job1][op1] <= start_times[job2][op2]) | (end_times[job2][op2] <= start_times[job1][op1])
            )

# Tardiness constraints
tardiness = [intvar(0, sum(total_processing_time)) for job in range(num_jobs)]
for job in range(num_jobs):
    constraints.append(tardiness[job] >= end_times[job][-1] - due_dates[job])
    constraints.append(tardiness[job] >= 0)

# Max tardiness
constraints.append(max_tardiness == max(tardiness))

# Objective
objective = minimize(max_tardiness)

# Add all constraints to the model
model = Model(constraints)
model += objective

# Solve model
solver = CPM_ortools(model)
solution = solver.solve()

if solution:
    print(""Solution found:"")
    for job in range(num_jobs):
        for op in range(len(jobs[job])):
            print(f""Job {job}, Operation {op}: Start = {start_times[job][op].value()}, End = {end_times[job][op].value()}"")
    print(f""Maximum Tardiness: {max_tardiness.value()}"")
else:
    print(""No solution found."")
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 4
number_of_machines = 5
maximum_duration = 20
due_date_allowance = 1.3

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(durations)

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)

# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))
        
    # First task of each job should be completed before the completion of any job
    for j in range(number_of_jobs):
        for i in range(number_of_jobs):
            if i != j:
                m += (end[j, 0] <= end[i, number_of_tasks - 1])

    # Objective
    m.minimize(max(tardiness))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Maximum Tardiness:"", max(tardiness.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 4  
number_of_machines = 5  
maximum_duration = 20
due_date_allowance = 1.3

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(sum(duration) for duration in durations)

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)

# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()

    # constraints
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [(end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                  for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                  if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))
    
    # The first task related to each job should be completed before the completion of any job
    for i in range(number_of_jobs):
        m += (end[:, 0] <= end[i, number_of_tasks - 1])
        
    # Objective
    m.minimize(max(tardiness))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
",Invalid: name 'due_date_allowance' is not defined,Valid,Valid,Invalid: list assignment index out of range
14,"Create job shop scheduling model with 5 jobs and 5 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. The objective function is maximum tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Job two has to be completed first","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 5  
number_of_machines = 5  
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(durations)

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)


# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m + (start[:, 0] >= release_times)
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))
        
    # Job two has to be completed first
    for i in range(number_of_jobs):
        if i != 1:
            m += (end[i, 4] > end[1, 4])

    # Objective
    m.minimize(max(tardiness))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())",Output:,"import random
import numpy as np
import cpmpy as cp

# Problem Constants
num_jobs = 5
num_machines = 5
max_duration = 20
due_date_allowance = 1.3

# Randomly generate release times
release_times = [random.randint(0, 50) for _ in range(num_jobs)]

# Randomly generate operations and durations
operations = []
durations = []

for job in range(num_jobs):
    num_operations = random.randint(1, num_machines)
    ops = random.sample(range(num_machines), num_operations)
    durs = [random.randint(1, max_duration) for _ in range(num_operations)]
    operations.append(ops)
    durations.append(durs)

# Calculate due dates
total_processing_times = [sum(durations[job]) for job in range(num_jobs)]
due_dates = [int(due_date_allowance * total_processing_times[job]) for job in range(num_jobs)]

# Variables
start_times = [[cp.intvar(release_times[job], sum(durations[job])) for _ in range(len(operations[job]))] for job in range(num_jobs)]
end_times = [[start_times[job][op] + durations[job][op] for op in range(len(operations[job]))] for job in range(num_jobs)]
job_end_times = [end_times[job][-1] for job in range(num_jobs)]
tardiness = [cp.if_then_else(job_end_times[job] > due_dates[job], job_end_times[job] - due_dates[job], 0) for job in range(num_jobs)]

# Constraints
constraints = []

# Job operations must follow their routes
for job in range(num_jobs):
    for op in range(1, len(operations[job])):
        constraints.append(start_times[job][op] >= end_times[job][op-1])

# Jobs on the same machine must not overlap
for machine in range(num_machines):
    for job1 in range(num_jobs):
        for job2 in range(job1 + 1, num_jobs):
            if machine in operations[job1] and machine in operations[job2]:
                op1 = operations[job1].index(machine)
                op2 = operations[job2].index(machine)
                constraints.append(start_times[job1][op1] >= end_times[job2][op2] or start_times[job2][op2] >= end_times[job1][op1])

# Job release times
for job in range(num_jobs):
    for op in range(len(operations[job])):
        constraints.append(start_times[job][op] >= release_times[job])

# Job two has to be completed first
for job in range(num_jobs):
    if job != 1:
        constraints.append(job_end_times[1] <= job_end_times[job])

# Objective: minimize maximum tardiness
max_tardiness = cp.max(tardiness)
model = cp.Model(constraints, minimize=max_tardiness)

# Solve the model
if model.solve():
    print(""Solution found:"")
    for job in range(num_jobs):
        print(f""Job {job}:"")
        for op in range(len(operations[job])):
            print(f""  Operation on machine {operations[job][op]} starts at {start_times[job][op].value()} and ends at {end_times[job][op].value()}"")
else:
    print(""No solution found."")
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 5  
number_of_machines = 5  
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(map(sum, durations))

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (due_date_allowance * np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0, maximum_release_time) for _ in range(number_of_jobs)]

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)

# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # Tardiness of each job

    # model
    m = Model()
    
    # constraints
    m += (start[:, 0] >= release_times)
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks - 1] - due_dates[j], 0]))
        
    # Job two has to be completed first
    for i in range(number_of_jobs):
        if i != 1:
            m += (end[i, number_of_tasks - 1] > end[1, number_of_tasks - 1])

    # Objective
    m.minimize(max(tardiness))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start, end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Maximum Tardiness:"", max(tardiness.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 5  
number_of_machines = 5  
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(map(sum, durations))

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)


# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m += (start[:, 0] >= release_times)
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
        
    # Job two has to be completed first
    for i in range(number_of_jobs):
        if i != 1:
            m += (end[1, -1] <= start[i, 0])
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))

    # Objective
    m.minimize(max(tardiness))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
",Invalid: name 'max_duration' is not defined,Valid,Valid,"Invalid: invalid syntax (<string>, line 1)"
15,"Create job shop scheduling model with 6 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. The objective function is maximum tardiness. Maximum duration is 25. After solving the problem, solutions will be printed and visualised.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 6  
number_of_machines = 6  
maximum_duration = 25
due_date_allowance = 1.3
maximum_release_time = 50

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(durations)

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)


# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m + (start[:, 0] >= release_times)
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))

    # Objective
    m.minimize(max(tardiness))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())","import pandas as pd
import numpy as np
import plotly.express as px
from cpmpy import *
import random
import math
from datetime import datetime
import pandas_datetime as pdm

# Define the problem parameters
num_jobs = 6
num_machines = 6
max_duration = 25
due_date_allowance = 1.3
random.seed(42)

# Define the arrival rate
lambda_values = [1, 2, 3, 4, 5]

# Define the utility function
u = np.array([1, 1, 1, 1, 1, 1])

# Define the processing time and due date functions
def arrival_time(num_jobs, lambda_value):
    return random.uniform(0, max_duration, num_jobs)

def due_date(num_jobs, max_duration):
    return due_date_allowance * max_duration

def processing_time(num_jobs, num_machines, max_duration):
    return random.uniform(0, max_duration, num_machines)

# Initialize the queue
queue = [0]
next_time = [0]
durations = [0]
end_times = [0]
lateness = [0]

# Initialize the solution
solution = [0]
best_tardiness = 0
best_solution = []
for i in range(num_jobs):
    if i == 0:
        solution[i] = arrival_time(num_jobs, lambda_values[0])
    else:
        solution[i] = solution[i - 1] + processing_time(num_jobs, num_machines, max_duration)

# Print the results
print(""Best tardiness:"", best_tardiness)
print(""Best solution:"")
print(solution)

# Visualize the results
fig, ax = px.line(x=range(len(solution)), y=durations, label=""Tardiness"")
ax.set_xlabel(""Job index"")
ax.set_ylabel(""Tardiness"")
ax.set_title(""Tardiness vs job index"")
ax.legend()
fig.show()

# End the simulation
for i in range(num_jobs):
    if solution[i] <= d[i]:
        next_time[i] = d[i] + random.uniform(0, 10)
    else:
        next_time[i] = next_time[i - 1] + processing_time(num_jobs, num_machines, max_duration)[i - 1]
        if i == len(solution) - 1:
            next_time[i] = max_duration

# Update the queue, next time, and durations
queue.extend(next_time)
next_time = next_time[1:]
durations = durations[1:]
end_times = end_time[1:]
lateness = [0]
for i in range(len(solution)):
    if i == 0:
        lateness[i] = next_time[i] - d[i]
    else:
        lateness[i] += d[i - 1] - next_time[i]
    next_time[i] -= d[i]
    end_times[i] += d[i]
    if i == len(solution) - 1:
        end_times[i] += max_duration

# Return the solution
return solution, lateness

# Solve the problem
solutions, latencies = solve(num_jobs, num_machines, max_duration)

# Print the results
print(""Solutions:"")
print(solutions)
print(""Latencies:"")
print(latencies)","import random
import numpy as np
from cpmpy import *

# Constants
num_jobs = 6
num_machines = 6
max_duration = 25
due_date_allowance = 1.3

# Generate random job data
processing_times = np.random.randint(1, max_duration+1, (num_jobs, num_machines))
release_times = np.random.randint(0, 51, num_jobs)
due_dates = np.sum(processing_times, axis=1) * due_date_allowance

# Create variables
start_times = intvar(0, sum(processing_times.flatten()), shape=(num_jobs, num_machines))
end_times = intvar(0, sum(processing_times.flatten()), shape=(num_jobs, num_machines))
tardiness = intvar(0, sum(processing_times.flatten()), shape=num_jobs)

# Constraints
model = Model()

for job in range(num_jobs):
    for machine in range(num_machines):
        model += (end_times[job, machine] == start_times[job, machine] + processing_times[job, machine])
        if machine > 0:
            model += (start_times[job, machine] >= end_times[job, machine-1])
        
        if job > 0:
            model += (start_times[job, machine] >= release_times[job])

# No overlap constraints
for machine in range(num_machines):
    for job1 in range(num_jobs):
        for job2 in range(job1+1, num_jobs):
            model += (start_times[job1, machine] >= end_times[job2, machine]) | (start_times[job2, machine] >= end_times[job1, machine])

# Tardiness calculation
for job in range(num_jobs):
    model += (tardiness[job] >= end_times[job, -1] - due_dates[job])

# Objective
model.minimize(max(tardiness))

# Solve model
if model.solve():
    for job in range(num_jobs):
        for machine in range(num_machines):
            print(f""Job {job+1}, Machine {machine+1}: Start {start_times[job, machine].value()}, End {end_times[job, machine].value()}"")
else:
    print(""No solution found"")
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 6  
number_of_machines = 6  
maximum_duration = 25
due_date_allowance = 1.3
maximum_release_time = 50

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(sum(durations, []))

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)

# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m += (start[:, 0] >= release_times)
    m += (end == start + durations)  # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))

    # Objective: Minimize maximum tardiness
    m.minimize(max(tardiness))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Maximum Tardiness:"", max(tardiness.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 6  
number_of_machines = 6  
maximum_duration = 25
due_date_allowance = 1.3
maximum_release_time = 50

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(map(sum, durations))

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance * np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0, maximum_release_time) for _ in range(number_of_jobs)]

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)

# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m += (start[:, 0] >= release_times)
    m += (end == start + durations)  # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [(end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                  for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                  if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))

    # Objective
    m.minimize(max(tardiness))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start, end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
",Invalid: Unrecognized linear expression: -127.4,Invalid: sum() takes 1 positional argument but 2 were given,Valid,"Invalid: 'return' outside function (<string>, line 89)"
16,"Create job shop scheduling model with 6 jobs and 6 machines. All jobs have random routes and their operations have random durations. The objective function is makespan. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Second task of Job two has to come before all the second tasks of other jobs","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 6  
number_of_machines = 6 
maximum_duration = 20

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(durations)

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)


# model
def model(jobs, last_time, durations, task_to_machine_mapping):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    
    # model
    m = Model()
    
    # constraints
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # The 2nd task of job 2 has to come before all 2nd tasks of other jobs
    for i in range(number_of_jobs):
        if i != 1:
            m += (start[i, 1] >= start[1, 1])

    # Objective
    m.minimize(max(end))

    return m, (start, end)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end)) = model(jobs, last_time, durations, task_to_machine_mapping)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Makespan:"", max(end.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())","import pandas as pd
import numpy as np
import lmfit
from lmfit import Minim
import matplotlib.pyplot as plt

# Define the model
class Model(Minim):
    def __init__(self, N, M, D, T, c):
        self.N = N  # Number of jobs
        self.M = M  # Number of machines
        self.D = D  # Duration of tasks
        self.T = T  # Task durations
        self.c = c  # Coefficients of the objective function
        self.setup()

    def setup(self):
        self.X = np.zeros((self.N, self.M))
        self.y = np.zeros(self.M)
        self.tau = np.zeros(self.M)
        self.c_sum = 0

    def _objective(self, X):
        y = np.zeros(self.M)
        for i, yi in enumerate(X):
            if yi == 1:
                y[i] = np.random.uniform(1, 20)
            else:
                y[i] = np.random.uniform(5, 15)
        return self.c[0] * np.sum(y) - self.c[1] * np.sum(np.cumsum(y))

    def _constraints(self):
        return [
            sum(X[i] for i in range(1, self.M + 1)) == 1 for _ in range(self.M + 1)
        ]

    def _bounds(self):
        return [[0, 1 for _ in range(self.M + 1)] for _ in range(self.M + 1)]

    def fit(self, *args):
        return Minim.minimize(self, args, method=' sii', bounds=self.bounds(), constraints=self._constraints(), lsq_options={'max_iter': 1000})

# Define parameters
N = 6  # Number of jobs
M = 6  # Number of machines
D = 20  # Duration of tasks
T = [1, 2, 3, 4, 5, 6]  # Task durations
c = [10, 5, 3, 2, 1, 4]  # Coefficients of the objective function

# Create a model
model = Model(N, M, D, T, c)

# Fit the model
model.fit()

# Print solutions
print(""Optimal solution:"")
print(""X:"", model.X)
print(""y:"", model.y)
print(""tau:"", model.tau)
print(""c_sum:"", model.c_sum)

# Visualize solutions
plt.figure(figsize=(10, 10))
for i, yi in enumerate(model.y):
    if yi == 1:
        plt.plot(i, yi, label=""j{}"".format(i))
plt.legend()
plt.show()

print(""Minimum Makespan:"", model.c_sum)","import random
from cpmpy import *
import numpy as np

# Constants
num_jobs = 6
num_machines = 6
max_duration = 20

# Generate random routes and durations for each job
jobs = []
for job_id in range(num_jobs):
    job = []
    for machine_id in range(num_machines):
        machine = random.randint(0, num_machines-1)
        duration = random.randint(1, max_duration)
        job.append((machine, duration))
    jobs.append(job)

# Create variables
makespan = intvar(0, sum(max_duration for job in jobs for _, max_duration in job), name=""makespan"")
start_times = [[intvar(0, makespan.ub, name=f""start_{j}_{o}"") for o in range(len(job))] for j, job in enumerate(jobs)]
end_times = [[intvar(0, makespan.ub, name=f""end_{j}_{o}"") for o in range(len(job))] for j, job in enumerate(jobs)]

# Constraints
constraints = []

# Precedence constraints within each job
for j, job in enumerate(jobs):
    for o in range(1, len(job)):
        constraints.append(start_times[j][o] >= end_times[j][o-1])

# Machine constraints
for m in range(num_machines):
    for j1 in range(num_jobs):
        for o1 in range(len(jobs[j1])):
            if jobs[j1][o1][0] == m:
                for j2 in range(j1+1, num_jobs):
                    for o2 in range(len(jobs[j2])):
                        if jobs[j2][o2][0] == m:
                            constraints.append(
                                (end_times[j1][o1] <= start_times[j2][o2]) |
                                (end_times[j2][o2] <= start_times[j1][o1])
                            )

# Duration constraints
for j, job in enumerate(jobs):
    for o, (m, d) in enumerate(job):
        constraints.append(end_times[j][o] == start_times[j][o] + d)

# Makespan constraints
for j, job in enumerate(jobs):
    constraints.append(makespan >= end_times[j][-1])

# Additional constraint: Second task of Job 2 has to come before all the second tasks of other jobs
for j in range(num_jobs):
    if j != 1:
        constraints.append(end_times[1][1] <= start_times[j][1])

# Define the model
model = Model(constraints)

# Solve the model
if model.solve():
    print(f""Makespan: {makespan.value()}"")
    for j in range(num_jobs):
        for o in range(len(jobs[j])):
            print(f""Job {j}, Operation {o}: Start at {start_times[j][o].value()}, End at {end_times[j][o].value()}"")
else:
    print(""No solution found"")
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 6  
number_of_machines = 6  
maximum_duration = 20

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(map(sum, durations))

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)

# model
def model(jobs, last_time, durations, task_to_machine_mapping):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task

    # model
    m = Model()
    
    # constraints
    m += (end == start + durations)  # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [(end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                  for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                  if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # Second task of Job two has to come before all the second tasks of other jobs
    for j in range(number_of_jobs):
        if j != 1:
            m += (end[1, 1] <= start[j, 1])

    # Objective: Minimize makespan
    m.minimize(max(end[:, -1]))

    return m, (start, end)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start, end)) = model(jobs, last_time, durations, task_to_machine_mapping)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Makespan:"", max(end[:, -1].value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 6  
number_of_machines = 6  
maximum_duration = 20

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(sum(d) for d in durations)

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)

# model
def model(jobs, last_time, durations, task_to_machine_mapping):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    
    # model
    m = Model()
    
    # constraints
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # Second task of Job two has to come before all the second tasks of other jobs
    for i in range(number_of_jobs):
        if i != 1:
            m += (end[1, 1] <= start[i, 1])

    # Objective
    m.minimize(max(end))

    return m, (start, end)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end)) = model(jobs, last_time, durations, task_to_machine_mapping)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Makespan:"", max(end.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
",Invalid: name 'makespan' is not defined,Valid,Valid,"Invalid: did you forget parentheses around the comprehension target? (<string>, line 38)"
17,"Create job shop scheduling model with 6 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total weighted tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 6  
number_of_machines = 6  
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50
weight_choices = [1, 2, 4]
probabilities = [0.2, 0.6, 0.2]

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(durations)

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]

def get_weights(weight_choices, probabilities, number_of_jobs):
    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
weights = get_weights(weight_choices, probabilities, number_of_jobs)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)


# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m + (start[:, 0] >= release_times)
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))

    # Objective
    m.minimize(sum(weights*tardiness))


    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Total Weighted Tardiness:"", sum(weights*tardiness.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())","# imports
import pandas as pd
import numpy as np
import plotly.express as px
from cpmpy import *
import random
import math
from datetime import datetime
import pandas_datetime as pdm

# settings
random.seed(1)
number_of_jobs = 6
number_of_machines = 6
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50
weight_choices = [1, 2, 4]
number_of_replications = 1000

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    durations = []
    for i in range(number_of_jobs):
        if maximum_duration != 0:
            durations.append([random.randint(1, maximum_duration) for _ in  range(number_of_machines)])
        else:
            durations.append(random.randint(1, maximum_duration) for _ in  range(number_of_machines))
    return durations

def get_last_time(durations):
    return sum(durations)

def get_tardiness(durations):
    return [sum(x for x in durations if x <= t for t in durations) for _ in range(number_of_jobs)]
    
def get_weights(number_of_choices):
    return [random.choices(weight_choices) for _ in  range(number_of_choices)]

def print_solutions(durations):
    for i, d in enumerate(durations):
        print(""Job {}: {}"".format(i, d))

def visualise(durations):
    fig, ax = px.line(x=durations, y=[i for i, _ in enumerate(durations)], labels=""durations"")
    ax.set_xlabel(""Job ID"")
    ax.set_ylabel(""Time"")
    ax.set_title(""durations"")
    fig.show()

# main
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_times = get_last_time(durations)
tardiness = get_tardiness(durations)
weights = get_weights(number_of_choices)
print_solutions(durations)
visualise(durations)
print(""best solutions:"")
for i, d in enumerate(durations):
    print(""Job {}: {}"".format(i, d))
print(""best last time:"", last_times[-1])
print(""best tardiness:"", sum(tardiness))
print(""best weights:"")
for i, w in enumerate(weights):
    print(""{} "".format(w))","import random
import numpy as np
import cpmpy as cp

# Parameters
num_jobs = 6
num_machines = 6
max_duration = 20
due_date_allowance = 1.3

# Data generation
random.seed(0)
durations = [[random.randint(1, max_duration) for _ in range(num_machines)] for _ in range(num_jobs)]
routes = [random.sample(range(num_machines), k=num_machines) for _ in range(num_jobs)]
release_times = [random.randint(0, 50) for _ in range(num_jobs)]
weights = [np.random.choice([1, 2, 4], p=[0.2, 0.6, 0.2]) for _ in range(num_jobs)]
due_dates = [int(sum(durations[j]) * due_date_allowance) for j in range(num_jobs)]

# Variables
start_times = [[cp.intvar(0, sum(durations[j]) + release_times[j]) for _ in range(num_machines)] for j in range(num_jobs)]
end_times = [[start_times[j][i] + durations[j][i] for i in range(num_machines)] for j in range(num_jobs)]
job_tardiness = [cp.intvar(0, sum(durations[j])) for j in range(num_jobs)]

# Constraints
model = cp.Model()

# Job operations order and release times
for j in range(num_jobs):
    for i in range(1, num_machines):
        model += (end_times[j][routes[j][i-1]] <= start_times[j][routes[j][i]])
    model += (start_times[j][routes[j][0]] >= release_times[j])

# Machine constraints (no overlap)
for m in range(num_machines):
    for j1 in range(num_jobs):
        for j2 in range(j1 + 1, num_jobs):
            for i1 in range(num_machines):
                for i2 in range(num_machines):
                    if routes[j1][i1] == m and routes[j2][i2] == m:
                        model += (end_times[j1][routes[j1][i1]] <= start_times[j2][routes[j2][i2]]) | \
                                 (end_times[j2][routes[j2][i2]] <= start_times[j1][routes[j1][i1]])

# Tardiness calculation
for j in range(num_jobs):
    model += (job_tardiness[j] >= end_times[j][routes[j][-1]] - due_dates[j])

# Objective function: Minimize total weighted tardiness
total_weighted_tardiness = sum(weights[j] * job_tardiness[j] for j in range(num_jobs))
model.minimize(total_weighted_tardiness)

# Solve and visualize
if model.solve():
    for j in range(num_jobs):
        print(f""Job {j}:"")
        for i in range(num_machines):
            print(f""  Operation on Machine {routes[j][i]}: Start at {start_times[j][routes[j][i]].value()}, Duration {durations[j][routes[j][i]]}, End at {end_times[j][routes[j][i]].value()}"")
        print(f""  Release time: {release_times[j]}, Due date: {due_dates[j]}, Tardiness: {job_tardiness[j].value()}, Weight: {weights[j]}"")
    print(f""Total weighted tardiness: {total_weighted_tardiness.value()}"")
else:
    print(""No solution found"")
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 6  
number_of_machines = 6  
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50
weight_choices = [1, 2, 4]
probabilities = [0.2, 0.6, 0.2]

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(map(sum, durations))

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]

def get_weights(weight_choices, probabilities, number_of_jobs):
    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
weights = get_weights(weight_choices, probabilities, number_of_jobs)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)

# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m += (start[:, 0] >= release_times)
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))

    # Objective: Minimize total weighted tardiness
    m.minimize(sum(weights[j] * tardiness[j] for j in range(number_of_jobs)))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Total Weighted Tardiness:"", sum(weights[j] * tardiness[j].value() for j in range(number_of_jobs)))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 6
number_of_machines = 6
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50
weight_choices = [1, 2, 4]
probabilities = [0.2, 0.6, 0.2]

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(map(sum, durations))

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines + 1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i + 1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance * np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0, maximum_release_time) for _ in range(number_of_jobs)]

def get_weights(weight_choices, probabilities, number_of_jobs):
    return random.choices(weight_choices, weights=probabilities, k=number_of_jobs)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
weights = get_weights(weight_choices, probabilities, number_of_jobs)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)

# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m += (start[:, 0] >= release_times)
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [(end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                  for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                  if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))
        
    # The first task related to each job should be completed before the completion of any job
    for i in range(number_of_jobs):
        m += (end[:, 0] <= end[i, number_of_tasks - 1])

    # Objective
    m.minimize(sum(weights * tardiness))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start, end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Total Weighted Tardiness:"", sum(weights * tardiness.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
",Invalid: name 'num_machines' is not defined,Invalid: name 'weights' is not defined,Valid,Invalid: No module named 'pandas_datetime'
18,"Create job shop scheduling model with 6 jobs and 5 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. The objective function is maximum tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. The first task related to each job shoub be completed before the completion of any job","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 6  
number_of_machines = 5  
maximum_duration = 20
due_date_allowance = 1.3

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(durations)

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)


# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    
    # model
    m = Model()
    
    # constraints
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))
    
    # The first task related to each job shoub be completed before the completion of any job
    for i in range(number_of_jobs):
        m += (end[:, 0] <= end[i, 4])
        
    # Objective
    m.minimize(max(tardiness))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())","import pandas as pd
import numpy as np
import lmfit
from lmfit import Minim
import plotly.express as px
from Chaco import Chaco
from scipy.stats import randint
import copy
from random import shuffle

# Define the problem parameters
num_jobs = 6
num_machines = 5
tolerance = 10
timeout = 20
*np.ones(num_jobs)
*1.3**np.arange(1,num_jobs+1)
*num_machines
*num_machines**num_jobs
print(f'Number of jobs: {num_jobs}')
print(f'Number of machines: {num_machines}')
print(f'Tolerance: {tolerance}')
print(f'Timeout: {timeout}')

# Define the objective function
def f(x):
    return sum([x[i] for i in range(num_jobs) if i!=0])
    
# Define the constraints
con = [(sum(x[i] for i in range(num_jobs))==1 for _ in range(num_machines)]
con.append(0<=x for _ in range(num_jobs))
con.append(x[i]<timeout for i in range(num_jobs))

# Solve the problem
result = Minim(f, con, method=' mme')
print(result.x)
print('Best solution:')
print(result.x)
print('Best objective value:',f(result.x))

# Visualize the results
fig, ax = Chaco.plot(result.x, label='Tasks')
ax.set_title('Visualizing the solution')
ax.set_xlabel('Tasks')
ax.set_ylabel('Times')
ax.legend()
fig.show()

# Print the results
print('Best solution:')
print(result.x)
print('Best objective value:',f(result.x))
print('Number of jobs:',num_jobs)
print('Number of machines:',num_machines)
print('Tolerance:',tolerance)
print('Timeout:',timeout)
print('Visualizations:')
print(fig)
print('Chaco visualizations:')
print(ax)
print('Done.')","import cpmpy as cp
import numpy as np

# Parameters
num_jobs = 6
num_machines = 5
max_duration = 20
due_date_allowance = 1.3
np.random.seed(0)

# Generate random routes and durations
jobs = []
durations = []
for j in range(num_jobs):
    num_operations = np.random.randint(1, num_machines + 1)
    route = np.random.choice(range(num_machines), num_operations, replace=False).tolist()
    duration = np.random.randint(1, max_duration + 1, num_operations).tolist()
    jobs.append(route)
    durations.append(duration)

# Calculate due dates
total_processing_times = [sum(durations[j]) for j in range(num_jobs)]
due_dates = [int(due_date_allowance * tpt) for tpt in total_processing_times]

# Decision variables
start_times = [[cp.intvar(0, sum(total_processing_times)) for _ in jobs[j]] for j in range(num_jobs)]
completion_times = [[cp.intvar(0, sum(total_processing_times)) for _ in jobs[j]] for j in range(num_jobs)]
tardiness = [cp.intvar(0, sum(total_processing_times)) for _ in range(num_jobs)]

# Constraints
constraints = []

# Each operation must start after the previous one finishes
for j in range(num_jobs):
    for o in range(1, len(jobs[j])):
        constraints.append(start_times[j][o] >= completion_times[j][o-1])

# Completion time = start time + duration
for j in range(num_jobs):
    for o in range(len(jobs[j])):
        constraints.append(completion_times[j][o] == start_times[j][o] + durations[j][o])

# Operations on the same machine cannot overlap
for m in range(num_machines):
    for j1 in range(num_jobs):
        for o1 in range(len(jobs[j1])):
            if jobs[j1][o1] == m:
                for j2 in range(j1 + 1, num_jobs):
                    for o2 in range(len(jobs[j2])):
                        if jobs[j2][o2] == m:
                            constraints.append(cp.all_different([start_times[j1][o1], start_times[j2][o2]]))

# Tardiness calculations
for j in range(num_jobs):
    constraints.append(tardiness[j] >= completion_times[j][-1] - due_dates[j])

# Objective: Minimize maximum tardiness
objective = cp.max(tardiness)

# Ensure the first task of each job finishes before any job completes
for j in range(num_jobs):
    for k in range(num_jobs):
        if j != k:
            constraints.append(completion_times[j][0] <= completion_times[k][-1])

# Model
model = cp.Model(constraints)
model.minimize(objective)

# Solve
if model.solve():
    for j in range(num_jobs):
        print(f""Job {j+1}:"")
        for o in range(len(jobs[j])):
            print(f""  Operation {o+1} on machine {jobs[j][o]} starts at {start_times[j][o].value()} and finishes at {completion_times[j][o].value()}"")
    print(f""Maximum tardiness: {objective.value()}"")

else:
    print(""No solution found"")
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 6  
number_of_machines = 5  
maximum_duration = 20
due_date_allowance = 1.3

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(sum(durations, []))

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (due_date_allowance * np.sum(durations, axis=1)).astype(int)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)

# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # Tardiness of each job

    # model
    m = Model()
    
    # constraints
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))
        
    # The first task related to each job should be completed before the completion of any job
    for j in range(number_of_jobs):
        for j2 in range(number_of_jobs):
            if j != j2:
                m += (end[j, 0] <= end[j2, number_of_tasks - 1])

    # Objective
    m.minimize(max(tardiness))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Maximum Tardiness:"", max(tardiness.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 6  
number_of_machines = 5  
maximum_duration = 20
due_date_allowance = 1.3

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(sum(durations, []))

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)


# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()

    # constraints
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))
    
    # The first task related to each job should be completed before the completion of any job
    for i in range(number_of_jobs):
        m += (end[:, 0] <= end[i, 4])
        
    # Objective
    m.minimize(max(tardiness))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
",Invalid: name 'durations' is not defined,Invalid: sum() takes 1 positional argument but 2 were given,Invalid: sum() takes 1 positional argument but 2 were given,"Invalid: closing parenthesis ']' does not match opening parenthesis '(' (<string>, line 30)"
19,"Create job shop scheduling model with 7 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total flow time (completion time - release time). Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Job two has to be completed first","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 7  
number_of_machines = 6  
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50
weight_choices = [1, 2, 4]
probabilities = [0.2, 0.6, 0.2]

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(durations)

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]

def get_weights(weight_choices, probabilities, number_of_jobs):
    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
weights = get_weights(weight_choices, probabilities, number_of_jobs)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)


# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m + (start[:, 0] >= release_times)
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))
        
    # Job two has to be completed first
    for i in range(number_of_jobs):
        if i != 1:
            m += (end[i, 5] > end[1, 5])

    # Objective
    m.minimize(sum(end[:, number_of_tasks -1] - release_times))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Total Flowtime:"", sum(end[:, number_of_machines-1].value() - release_times))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())","# imports
import pandas as pd
import numpy as np
import plotly.express as px
from cpmpy import *
import random

# settings
random.seed(1)
number_of_jobs = 7
number_of_machines = 6
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50
weight_choices = [1, 2, 4]
probabilities = [0.2, 0.6, 0.2]

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    durations = []
    for i in range(number_of_jobs):
        if(i==1 or i==3):
            durations.append([random.randint(1, maximum_duration) for _ in  range(number_of_machines)])
        else:
            durations.append([random.randint(1, maximum_duration) for _ in  range(number_of_machines)])
    return durations

def get_last_time(durations):
    return sum(durations)

def get_simulated_system(number_of_jobs, number_of_machines, maximum_duration, due_date_allowance, maximum_release_time, weight_choices, probabilities):
    durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
    last_time = get_last_time(durations)
    simulated_durations = [random.choices(durations, k=number_of_machines) for _ in  range(number_of_jobs)]
    simulated_last_time = [get_last_time(durations) for  durations in simulated_durations]
    return  simulated_durations, simulated_last_time

# simulations
durations,  last_time = get_simulated_system(number_of_jobs, number_of_machines, maximum_duration, due_date_allowance, maximum_release_time, weight_choices, probabilities)

# printing and visualiztion
print(""best_durations:"", last_time)
print(""best_flow_time:"", last_time[0]-0.1*last_time[0])
print(""results:"", durations)
fig = px.line(last_time, label=""Completion time"")
fig.update_layout(title=""Job shop simulation"", xaxis_title=""Time"", yaxis_title=""Completion time"")
fig.show()

# printing results
for i, d in enumerate(durations):
    print(""job {}: {} units\n"".format(i+1,  d))","import cpmpy as cp
import numpy as np

# Problem parameters
num_jobs = 7
num_machines = 6
max_duration = 20

# Random seed for reproducibility
np.random.seed(0)

# Generate random routes and durations
durations = np.random.randint(1, max_duration + 1, size=(num_jobs, num_machines))
routes = np.random.randint(0, num_machines, size=(num_jobs, num_machines))

# Generate random release times
release_times = np.random.randint(0, 51, size=num_jobs)

# Generate job weights
weights = np.random.choice([1, 2, 4], size=num_jobs, p=[0.2, 0.6, 0.2])

# Calculate due dates
total_processing_times = np.sum(durations, axis=1)
due_dates = total_processing_times * 1.3

# Variables
start_times = cp.intvar(0, sum(due_dates), shape=(num_jobs, num_machines), name=""start_times"")
end_times = cp.intvar(0, sum(due_dates), shape=(num_jobs, num_machines), name=""end_times"")
job_end_times = cp.intvar(0, sum(due_dates), shape=num_jobs, name=""job_end_times"")

model = cp.Model()

# Constraints
for j in range(num_jobs):
    for o in range(num_machines):
        # Ensure operations follow the order
        if o > 0:
            model += (start_times[j, o] >= end_times[j, o - 1])
        # Ensure jobs respect release times
        if o == 0:
            model += (start_times[j, o] >= release_times[j])
        # Ensure end time is start time + duration
        model += (end_times[j, o] == start_times[j, o] + durations[j, o])
        # Ensure machine is available
        for j2 in range(num_jobs):
            if j != j2:
                for o2 in range(num_machines):
                    if routes[j, o] == routes[j2, o2]:
                        model += (cp.maximum(start_times[j, o], start_times[j2, o2]) >= cp.minimum(end_times[j, o], end_times[j2, o2]))

# Ensure job two is completed first
for j in range(num_jobs):
    if j != 1:
        model += (job_end_times[1] <= job_end_times[j])

# Calculate job end times
for j in range(num_jobs):
    model += (job_end_times[j] == end_times[j, num_machines - 1])

# Objective: Minimize total flow time
total_flow_time = cp.sum([job_end_times[j] - release_times[j] for j in range(num_jobs)])
model.minimize(total_flow_time)

# Solve model
solver = cp.SolverLookup.get(""ortools"")
if solver.solve():
    print(""Solution found:"")
    for j in range(num_jobs):
        for o in range(num_machines):
            print(f""Job {j}, Operation {o}, Start: {start_times[j, o].value()}, End: {end_times[j, o].value()}"")
    print(f""Total flow time: {total_flow_time.value()}"")
else:
    print(""No solution found."")
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 7  
number_of_machines = 6  
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50
weight_choices = [1, 2, 4]
probabilities = [0.2, 0.6, 0.2]

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(map(sum, durations))

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]

def get_weights(weight_choices, probabilities, number_of_jobs):
    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
weights = get_weights(weight_choices, probabilities, number_of_jobs)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)

# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m += (start[:, 0] >= release_times)
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))
        
    # Job two has to be completed first
    for i in range(number_of_jobs):
        if i != 1:
            m += (end[i, number_of_tasks - 1] > end[1, number_of_tasks - 1])

    # Objective
    m.minimize(sum(end[:, number_of_tasks -1] - release_times))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Total Flowtime:"", sum(end[:, number_of_machines-1].value() - release_times))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 7  
number_of_machines = 6  
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50
weight_choices = [1, 2, 4]
probabilities = [0.2, 0.6, 0.2]

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(durations)

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]

def get_weights(weight_choices, probabilities, number_of_jobs):
    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
weights = get_weights(weight_choices, probabilities, number_of_jobs)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)


# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m += (start[:, 0] >= release_times)
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))
    
    # Job two has to be completed first
    for i in range(number_of_jobs):
        if i != 1:
            m += (end[i, number_of_tasks - 1] >= end[1, number_of_tasks - 1])

    # Objective
    m.minimize(sum(end[:, number_of_tasks -1] - release_times))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Total Flowtime:"", sum(end[:, number_of_machines-1].value() - release_times))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
",Invalid: IntVar upperbound must be integer <class 'numpy.float64'> 595.4000000000001,Valid,Valid,Invalid: name 'get_durations' is not defined
20,"Create job shop scheduling model with 7 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total weighted tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 7  
number_of_machines = 6  
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50
weight_choices = [1, 2, 4]
probabilities = [0.2, 0.6, 0.2]

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(durations)

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]

def get_weights(weight_choices, probabilities, number_of_jobs):
    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
weights = get_weights(weight_choices, probabilities, number_of_jobs)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)


# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m + (start[:, 0] >= release_times)
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))

    # Objective
    m.minimize(sum(weights*tardiness))


    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start,end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Total Weighted Tardiness:"", sum(weights*tardiness.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())","# imports
import pandas as pd
import numpy as np
import plotly.express as px
from cpmpy import *
import random
import math
from datetime import datetime
import pandas_datetime as pdm

# settings
random.seed(1)
number_of_jobs = 7
number_of_machines = 6
number_of_durations = 20
number_of_weights = 3
maximum_duration = 20
number_of_release_values = 50
weight_intervals = [1, 2, 4]
due_date_allowances = 1.3
release_values = []
weights = []
for i in range(1, number_of_weights + 1):
    weight_intervals[i - 1] = (i - 0.5) / float(number_of_weights) * 100
    release_values.append(random.uniform(*weight_intervals[i - 1]))
    weights.append(random.uniform(*weight_intervals[i - 1]))

# utility functions
def get_durations(number_of_machines, number_of_durations, number_of_release_values):
    durations = []
    for i in range(number_of_durations):
        durations.append(random.uniform(*(0, maximum_duration))
    return durations

def get_last_time(number_of_machines, number_of_durations):
    return sum(durations for durations in durations)

def get_next_time(t, d):
    return t + d

# create simulations
durations = get_durations(number_of_machines, number_of_durations, number_of_release_values)
last_times = get_last_time(number_of_machines, number_of_durations)
next_times = get_next_time

# create scheduler
scheduler = CPYSchedule()
for i in range(number_of_durations):
    job_i = Job(i, durations[i], weights[i])
    scheduler.add(job_i)
for i in range(number_of_machines):
    job_i = Machine(i, last_times[i])
    scheduler.add(job_i)

# add constraints
for i in range(number_of_durations):
    scheduler.add(task_depends_on(i + 1, i) for i in range(number_of_durations))
for i in range(number_of_machines):
    scheduler.add(task_cannot_start(i, i + 1) for i in range(number_of_machines))

# set objective function
scheduler.set_objective( obiettivi[-1])
# print and visualize solution
print(""solutions:"")
for i in range(len(durations)):
    print(durations[i])
print(""Last time:"", last_times[-1])
print(""next time:"", next_times[-1])
print(""---------------------"")
visual = px.line(x=range(len(durations)), y=durations, label=""durations"")
visual += px.line(x=range(len(durations)), y=last_times, label=""last_times"")
visual += px.line(x=range(len(durations)), y=next_times, label=""next_times"")
visual.update_layout(title=""Job Shop Scheduling"", xaxis_title=""index"", yaxis_title=""time"")
visual.show()","import numpy as np
from cpmpy import *
from cpmpy.solvers import CPM_ortools

# Constants
num_jobs = 7
num_machines = 6
max_duration = 20
due_date_allowance = 1.3
release_time_max = 50

# Generate random job data
np.random.seed(0)  # For reproducibility
jobs = []
durations = []
weights = []

# Randomly generate job details
for _ in range(num_jobs):
    route_length = np.random.randint(1, num_machines + 1)
    route = np.random.choice(range(num_machines), size=route_length, replace=False)
    job_durations = np.random.randint(1, max_duration + 1, size=route_length)
    release_time = np.random.randint(0, release_time_max + 1)
    total_processing_time = sum(job_durations)
    due_date = int(total_processing_time * due_date_allowance)
    weight = np.random.choice([1, 2, 4], p=[0.2, 0.6, 0.2])
    jobs.append({'route': route, 'durations': job_durations, 'release_time': release_time, 
                 'due_date': due_date, 'weight': weight})

# Variables
start_times = [[intvar(0, sum(j['durations']) * 2) for _ in j['route']] for j in jobs]
end_times = [[intvar(0, sum(j['durations']) * 2) for _ in j['route']] for j in jobs]

# Model
model = Model()

# Constraints
for j_idx, job in enumerate(jobs):
    for o_idx in range(len(job['route'])):
        # Start time constraints
        if o_idx == 0:
            model += (start_times[j_idx][o_idx] >= job['release_time'])
        else:
            model += (start_times[j_idx][o_idx] >= end_times[j_idx][o_idx - 1])
        
        # End time constraints
        model += (end_times[j_idx][o_idx] == start_times[j_idx][o_idx] + job['durations'][o_idx])
        
        # Machine constraints
        machine = job['route'][o_idx]
        for other_j_idx, other_job in enumerate(jobs):
            if other_j_idx != j_idx:
                for other_o_idx, other_machine in enumerate(other_job['route']):
                    if other_machine == machine:
                        model += (start_times[j_idx][o_idx] >= end_times[other_j_idx][other_o_idx]) | \
                                 (start_times[other_j_idx][other_o_idx] >= end_times[j_idx][o_idx])

# Tardiness and objective function
total_weighted_tardiness = intvar(0, sum(j['due_date'] * j['weight'] for j in jobs))
tardiness = [intvar(0, sum(j['durations']) * 2) for j in jobs]

for j_idx, job in enumerate(jobs):
    model += (tardiness[j_idx] >= end_times[j_idx][-1] - job['due_date'])
    model += (tardiness[j_idx] >= 0)

model += (total_weighted_tardiness == sum(job['weight'] * tardiness[j_idx] for j_idx, job in enumerate(jobs)))
model.minimize(total_weighted_tardiness)

# Solve and print solution
solver = CPM_ortools(model)
if solver.solve():
    print(""Solution found:"")
    for j_idx, job in enumerate(jobs):
        print(f""Job {j_idx}:"")
        for o_idx in range(len(job['route'])):
            print(f""\tOperation {o_idx} on machine {job['route'][o_idx]}: ""
                  f""Start = {start_times[j_idx][o_idx].value()}, ""
                  f""End = {end_times[j_idx][o_idx].value()}"")
else:
    print(""No solution found."")
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 7  
number_of_machines = 6  
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50
weight_choices = [1, 2, 4]
probabilities = [0.2, 0.6, 0.2]

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum([sum(d) for d in durations])

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]

def get_weights(weight_choices, probabilities, number_of_jobs):
    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
weights = get_weights(weight_choices, probabilities, number_of_jobs)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)

# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m += (start[:, 0] >= release_times)
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))

    # Objective
    m.minimize(sum(tardiness * weights))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start, end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Total Weighted Tardiness:"", sum(tardiness.value() * weights))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random

# configurations
random.seed(1)
number_of_jobs = 7  
number_of_machines = 6  
maximum_duration = 20
due_date_allowance = 1.3
maximum_release_time = 50
weight_choices = [1, 2, 4]
probabilities = [0.2, 0.6, 0.2]

# utility functions
def get_durations(number_of_jobs, number_of_machines, maximum_duration):
    return [[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)]

def get_last_time(durations):
    return sum(map(sum, durations))

def get_task_to_machine_mapping(number_of_jobs, number_of_machines):
    return [random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)]

def get_jobs(number_of_jobs):
    return [f""Job Number{i+1}"" for i in range(number_of_jobs)]

def get_due_dates(due_date_allowance, durations):
    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)

def get_release_times(number_of_jobs, maximum_release_time):
    return [random.randint(0, maximum_release_time) for _ in range(number_of_jobs)]

def get_weights(weight_choices, probabilities, number_of_jobs):
    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)

# data preparation
durations = get_durations(number_of_jobs, number_of_machines, maximum_duration)
last_time = get_last_time(durations)
due_dates = get_due_dates(due_date_allowance, durations)
release_times = get_release_times(number_of_jobs, maximum_release_time)
weights = get_weights(weight_choices, probabilities, number_of_jobs)
task_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)
jobs = get_jobs(number_of_jobs)

# model
def model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights):
    durations = np.array(durations)
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    # Decision variables
    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""start"")  # Start time of each task
    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=""end"")  # End time of each task
    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=""tardiness"")  # tardiness of each job

    # model
    m = Model()
    
    # constraints
    m += (start[:, 0] >= release_times)
    m += (end == start + durations) # The end of every task is the sum of its start and duration

    # No overlap on the same machine
    for j in range(number_of_jobs): 
        for t in range(number_of_tasks):
            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])
                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)
                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]

    # Precedences: do tasks in order for all jobs
    for t in range(number_of_tasks - 1):
        m += [start[:, t + 1] >= end[:, t]]
    
    # calculate tardiness
    for j in range(number_of_jobs):
        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))
    
    # Objective
    m.minimize(sum(weights * tardiness))

    return m, (start, end, tardiness)

# visualization
def visualize(jobs, task_to_machine_mapping, start, end):
    task_to_machine_mapping = np.array(task_to_machine_mapping)
    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns

    job_names = np.repeat(jobs, number_of_tasks)
    full_names = np.array([[f""Task {j}_{t}"" for t in range(number_of_tasks)] for j in jobs])
    df = pd.DataFrame({'Start': start.flatten(),
                       'End': end.flatten(),
                       'Machine': task_to_machine_mapping.flatten().astype(str),
                       'Job': job_names.flatten(),
                       'Name': full_names.flatten(),
                       })
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    return fig.show()

# variables, constraints, and the model
(model, (start, end, tardiness)) = model(jobs, last_time, durations, task_to_machine_mapping, due_dates, release_times, weights)

# solve
sat = model.solve()
if not sat: raise Exception(""No solution found."")
    
# output
print(""Total Weighted Tardiness:"", sum(weights*tardiness.value()))
print(""Start times:"", start.value())
print(""End times:"", end.value())
print(""Tardiness:"", tardiness.value())

# visualize
visualize(jobs, task_to_machine_mapping, start.value(), end.value())
",Invalid: name 'tardiness' is not defined,Valid,Valid,"Invalid: '(' was never closed (<string>, line 32)"

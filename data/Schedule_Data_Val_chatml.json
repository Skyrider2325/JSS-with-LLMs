{
    "messages": [
        [
            {
                "role": "user",
                "content": "Create job shop scheduling model with 7 jobs and 5 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. The objective function is maximum tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Fifth task of Job five should be the last task to complete"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 7  \nnumber_of_machines = 5  \nmaximum_duration = 20\ndue_date_allowance = 1.3\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return np.array([[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)])\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return np.array([random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)])\n\ndef get_jobs(number_of_jobs):\n    return [f\"\"Job Number{i+1}\"\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n# model\ndef model(last_time, task_to_machine_mapping):\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"\"start\"\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"\"end\"\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"\"tardiness\"\")  # tardiness of each job\n\n    \n    # model\n    m = Model()\n    return m, (start, end, tardiness)\n# constraints\ndef constraints(m, start, end, tardiness, durations, task_to_machine_mapping, due_dates):\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n        \n     # Fifth task of Job five should be the last task to complete\n    for i in range(number_of_jobs):\n        if i != 4:\n            m += (end[i, 4] <= start[4, 4])\n    return m\n# Objective\ndef objective(m, tardiness):\n    m.minimize(max(tardiness))\n\n    return m\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"\"Task {j}_{t}\"\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"\"Start\"\", x=\"\"Time\"\", y=\"\"Machine\"\", color=\"\"Job\"\", text=\"\"Name\"\")\n    return fig.show()\n#define model\n(model, (start,end, tardiness)) = model(last_time, task_to_machine_mapping)\n\n#define constraints\nmodel = constraints(model, start, end, tardiness, durations, task_to_machine_mapping, due_dates)\n\n#define objective\nmodel = objective(model, tardiness)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"\"No solution found.\"\")\n    \n# output\nprint(\"\"Max Tardiness:\"\", max(tardiness.value()))\nprint(\"\"Start times:\"\", start.value())\nprint(\"\"End times:\"\", end.value())\nprint(\"\"Tardiness:\"\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 6 jobs and 5 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. The objective function is maximum tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised.Note: Job two has to be completed first"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 6  \nnumber_of_machines = 5  \nmaximum_duration = 20\ndue_date_allowance = 1.3\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return np.array([[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)])\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return np.array([random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)])\n\ndef get_jobs(number_of_jobs):\n    return [f\"\"Job Number{i+1}\"\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n# model\ndef model(last_time, task_to_machine_mapping):\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"\"start\"\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"\"end\"\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"\"tardiness\"\")  # tardiness of each job\n\n    \n    # model\n    m = Model()\n    return m, (start, end, tardiness)\n# constraints\ndef constraints(m, start, end, durations, task_to_machine_mapping, due_dates):\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n        \n    # Job two has to be completed first\n    for i in range(number_of_jobs):\n        if i != 1:\n            m += (end[i, 4] > end[1, 4]) \n    return m\n# Objective\ndef objective(m, tardiness):\n    m.minimize(max(tardiness))\n\n    return m\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"\"Task {j}_{t}\"\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"\"Start\"\", x=\"\"Time\"\", y=\"\"Machine\"\", color=\"\"Job\"\", text=\"\"Name\"\")\n    return fig.show()\n#define model\n(model, (start,end, tardiness)) = model(last_time, task_to_machine_mapping)\n\n#define constraints\nmodel = constraints(model, start, end, durations, task_to_machine_mapping, due_dates)\n\n#define objective\nmodel = objective(model, tardiness)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"\"No solution found.\"\")\n    \n# output\nprint(\"\"Max Tardiness:\"\", max(tardiness.value()))\nprint(\"\"Start times:\"\", start.value())\nprint(\"\"End times:\"\", end.value())\nprint(\"\"Tardiness:\"\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 4 jobs and 5 machines. All jobs have random routes and their operations have random durations. The objective function is makespan. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Job two has to be completed first"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 4  \nnumber_of_machines = 5  \nmaximum_duration = 20\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return np.array([[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)])\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return np.array([random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)])\n\ndef get_jobs(number_of_jobs):\n    return [f\"\"Job Number{i+1}\"\" for i in range(number_of_jobs)]\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n# model\ndef model(last_time, task_to_machine_mapping):\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"\"start\"\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"\"end\"\")  # End time of each task\n    \n    # model\n    m = Model()\n    return m , (start, end)\n# constraints\ndef constraints(m, start, end, durations, task_to_machine_mapping):\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # Job two has to be completed first\n    for i in range(number_of_jobs):\n        if i != 1:\n            m += (end[i, 4] > end[1, 4])\n    return m\n# Objective\ndef objective(m, end):\n    m.minimize(max(end))\n\n    return m\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"\"Task {j}_{t}\"\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"\"Start\"\", x=\"\"Time\"\", y=\"\"Machine\"\", color=\"\"Job\"\", text=\"\"Name\"\")\n    return fig.show()\n#define model\n(model, (start,end)) = model(last_time, task_to_machine_mapping)\n\n#define constraints\nmodel = constraints(model, start, end, durations, task_to_machine_mapping)\n\n#define objective\nmodel = objective(model, end)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"\"No solution found.\"\")\n    \n# output\nprint(\"\"Makespan:\"\", max(end.value()))\nprint(\"\"Start times:\"\", start.value())\nprint(\"\"End times:\"\", end.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 6 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. The objective function is maximum tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised."
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 6  \nnumber_of_machines = 6  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return np.array([[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)])\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return np.array([random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)])\n\ndef get_jobs(number_of_jobs):\n    return [f\"\"Job Number{i+1}\"\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n# model\ndef model(last_time, task_to_machine_mapping):\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"\"start\"\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"\"end\"\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"\"tardiness\"\")  # tardiness of each job\n\n    # model\n    m = Model()\n    return m , (start, end, tardiness)\n# constraints\ndef constraints(model, start, end, durations, task_to_machine_mapping, due_dates, release_times):\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape\n    model + (start[:, 0] >= release_times)\n    model += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            model += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        model += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        model += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n    return model\n# Objective\ndef objective(model, tardiness):\n    model.minimize(max(tardiness))\n\n    return model\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"\"Task {j}_{t}\"\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"\"Start\"\", x=\"\"Time\"\", y=\"\"Machine\"\", color=\"\"Job\"\", text=\"\"Name\"\")\n    return fig.show()\n#define model\n(model, (start,end, tardiness)) = model(last_time, task_to_machine_mapping)\n\n#define constraints\nmodel = constraints(model, start, end, durations, task_to_machine_mapping, due_dates, release_times)\n\n#define objective\nmodel = objective(model, tardiness)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"\"No solution found.\"\")\n    \n# output\nprint(\"\"Max Tardiness:\"\", max(tardiness.value()))\nprint(\"\"Start times:\"\", start.value())\nprint(\"\"End times:\"\", end.value())\nprint(\"\"Tardiness:\"\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 6 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. The objective function is maximum tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Job two and four will have task durations in minutes. Other jobs will have task durations in seconds"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 6  \nnumber_of_machines = 6  \nmaximum_duration = 20\ndue_date_allowance = 1.3\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    durations = []\n    for i in range(number_of_jobs):\n        if(i==1 or i==3):\n            durations.append([random.randint(1, maximum_duration)*60 for _ in  range(number_of_machines)]) \n        else:\n            durations.append([random.randint(1, maximum_duration) for _ in  range(number_of_machines)])\n        \n    return np.array(durations)\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return np.array([random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)])\n\ndef get_jobs(number_of_jobs):\n    return [f\"\"Job Number{i+1}\"\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n# model\ndef model(last_time, task_to_machine_mapping):\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"\"start\"\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"\"end\"\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"\"tardiness\"\")  # tardiness of each job\n\n    \n    # model\n    m = Model()\n    return m, (start, end, tardiness)\n# constraints\ndef constraints(m, start, end, tardiness, durations, task_to_machine_mapping, due_dates):\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n    return m\n# Objective\ndef objective(m, tardiness):\n    m.minimize(max(tardiness))\n\n    return m\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"\"Task {j}_{t}\"\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"\"Start\"\", x=\"\"Time\"\", y=\"\"Machine\"\", color=\"\"Job\"\", text=\"\"Name\"\")\n    return fig.show()\n#define model\n(model, (start,end, tardiness)) = model(last_time, task_to_machine_mapping)\n\n#define constraints\nmodel = constraints(model, start, end, tardiness, durations, task_to_machine_mapping, due_dates)\n\n#define objective\nmodel = objective(model, tardiness)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"\"No solution found.\"\")\n    \n# output\nprint(\"\"Max Tardiness:\"\", max(tardiness.value()))\nprint(\"\"Start times:\"\", start.value())\nprint(\"\"End times:\"\", end.value())\nprint(\"\"Tardiness:\"\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 5 jobs and 5 machines. All jobs have random routes and their operations have random durations. The objective function is makespan. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: The first task related to each job shoub be completed before the completion of any job."
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 5  \nnumber_of_machines = 5  \nmaximum_duration = 20\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return np.array([[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)])\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return np.array([random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)])\n\ndef get_jobs(number_of_jobs):\n    return [f\"\"Job Number{i+1}\"\" for i in range(number_of_jobs)]\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n# model\ndef model(last_time, task_to_machine_mapping):\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"\"start\"\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"\"end\"\")  # End time of each task\n    \n    # model\n    m = Model()\n    return m, (start, end)\n# constraints\ndef constraints(m, start, end, durations, task_to_machine_mapping):\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # The first task related to each job shoub be completed before the completion of any job\n    for i in range(number_of_jobs):\n        m += (end[:, 0] <= end[i, 4])\n    return m\n# Objective\ndef objective(m, end):\n    m.minimize(max(end))\n\n    return m\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"\"Task {j}_{t}\"\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"\"Start\"\", x=\"\"Time\"\", y=\"\"Machine\"\", color=\"\"Job\"\", text=\"\"Name\"\")\n    return fig.show()\n#define model\n(model, (start,end)) = model(last_time, task_to_machine_mapping)\n\n#define constraints\nmodel = constraints(model, start, end, durations, task_to_machine_mapping)\n\n#define objectives\nmodel = objective(model, end)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"\"No solution found.\"\")\n    \n# output\nprint(\"\"Makespan:\"\", max(end.value()))\nprint(\"\"Start times:\"\", start.value())\nprint(\"\"End times:\"\", end.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 6 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total weighted tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Job two has to be completed first"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 6  \nnumber_of_machines = 6  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\nweight_choices = [1, 2, 4]\nprobabilities = [0.2, 0.6, 0.2]\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return np.array([[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)])\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return np.array([random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)])\n\ndef get_jobs(number_of_jobs):\n    return [f\"\"Job Number{i+1}\"\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\ndef get_weights(weight_choices, probabilities, number_of_jobs):\n    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\nweights = get_weights(weight_choices, probabilities, number_of_jobs)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n# model\ndef model(last_time, task_to_machine_mapping):\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"\"start\"\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"\"end\"\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"\"tardiness\"\")  # tardiness of each job\n\n    # model\n    m = Model()\n    return m, (start, end, tardiness)\n# constraints\ndef constraints(m, start, end, tardiness, durations, task_to_machine_mapping, due_dates, release_times):\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n        \n    # Job two has to be completed first\n    for i in range(number_of_jobs):\n        if i != 1:\n            m += (end[i, 5] > end[1, 5])\n    return m\n# Objective\ndef objective(m, weights, tardiness):\n    m.minimize(sum(weights*tardiness))\n\n\n    return m\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"\"Task {j}_{t}\"\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"\"Start\"\", x=\"\"Time\"\", y=\"\"Machine\"\", color=\"\"Job\"\", text=\"\"Name\"\")\n    return fig.show()\n#define model\n(model, (start,end, tardiness)) = model(last_time, task_to_machine_mapping)\n#define constraints\nmodel = constraints(model, start, end, tardiness, durations, task_to_machine_mapping, due_dates, release_times)\n\n#define objective\nmodel = objective(model, weights, tardiness)\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"\"No solution found.\"\")\n    \n# output\nprint(\"\"Total Weighted Tardiness:\"\", sum(weights*tardiness.value()))\nprint(\"\"Start times:\"\", start.value())\nprint(\"\"End times:\"\", end.value())\nprint(\"\"Tardiness:\"\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 4 jobs and 4 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total weighted tardiness. Maximum duration is 20. After solving the problem, solutions will be printed and visualised."
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 4  \nnumber_of_machines = 4  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\nweight_choices = [1, 2, 4]\nprobabilities = [0.2, 0.6, 0.2]\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return np.array([[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)])\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return np.array([random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)])\n\ndef get_jobs(number_of_jobs):\n    return [f\"\"Job Number{i+1}\"\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\ndef get_weights(weight_choices, probabilities, number_of_jobs):\n    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\nweights = get_weights(weight_choices, probabilities, number_of_jobs)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n# model\ndef model(last_time, task_to_machine_mapping):\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"\"start\"\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"\"end\"\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"\"tardiness\"\")  # tardiness of each job\n\n    # model\n    m = Model()\n    return m, (start, end, tardiness)\n# constraints\ndef constraints(model, start, end, tardiness, durations, task_to_machine_mapping, due_dates, release_times):\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape\n    model + (start[:, 0] >= release_times)\n    model += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            model += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        model += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        model += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n    return model\n# Objective\ndef objective(model, weights, tardiness):\n    model.minimize(sum(weights*tardiness))\n\n\n    return model\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"\"Task {j}_{t}\"\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"\"Start\"\", x=\"\"Time\"\", y=\"\"Machine\"\", color=\"\"Job\"\", text=\"\"Name\"\")\n    return fig.show()\n#define model\n(model, (start,end, tardiness)) = model(last_time, task_to_machine_mapping)\n\n#define constraints\nmodel = constraints(model, start, end, tardiness, durations, task_to_machine_mapping, due_dates, release_times)\n\n#define objective\nmodel = objective(model, weights, tardiness)\n\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"\"No solution found.\"\")\n    \n# output\nprint(\"\"Total Weighted Tardiness:\"\", sum(weights*tardiness.value()))\nprint(\"\"Start times:\"\", start.value())\nprint(\"\"End times:\"\", end.value())\nprint(\"\"Tardiness:\"\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 7 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total flow time (completion time - release time). Maximum duration is 20. Note: Job two and four will have task durations in minutes. Other jobs will have task durations in seconds"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 7  \nnumber_of_machines = 6  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\nweight_choices = [1, 2, 4]\nprobabilities = [0.2, 0.6, 0.2]\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    durations = []\n    for i in range(number_of_jobs):\n        if(i==1 or i==3):\n            durations.append([random.randint(1, maximum_duration)*60 for _ in  range(number_of_machines)]) \n        else:\n            durations.append([random.randint(1, maximum_duration) for _ in  range(number_of_machines)])\n        \n    return np.array(durations)\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return np.array([random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)])\n\ndef get_jobs(number_of_jobs):\n    return [f\"\"Job Number{i+1}\"\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\ndef get_weights(weight_choices, probabilities, number_of_jobs):\n    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\nweights = get_weights(weight_choices, probabilities, number_of_jobs)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n# model\ndef model(last_time, task_to_machine_mapping):\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"\"start\"\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"\"end\"\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"\"tardiness\"\")  # tardiness of each job\n\n    # model\n    m = Model()\n    return m, (start, end, tardiness)\n# constraints\ndef constraints(m, start, end, tardiness, durations, task_to_machine_mapping, due_dates, release_times):\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n    return m\n# Objective\ndef objective(m, end, release_times, task_to_machine_mapping):\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape\n    m.minimize(sum(end[:, number_of_tasks -1] - release_times))\n\n    return m\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"\"Task {j}_{t}\"\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"\"Start\"\", x=\"\"Time\"\", y=\"\"Machine\"\", color=\"\"Job\"\", text=\"\"Name\"\")\n    return fig.show()\n#define model\n(model, (start,end, tardiness)) = model(last_time, task_to_machine_mapping)\n\n#define constraints\nmodel = constraints(model, start, end, tardiness, durations, task_to_machine_mapping, due_dates, release_times)\n#define objective\nmodel = objective(model, end, release_times, task_to_machine_mapping)\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"\"No solution found.\"\")\n    \n# output\nprint(\"\"Total Flowtime:\"\", sum(end[:, number_of_machines-1].value() - release_times))\nprint(\"\"Start times:\"\", start.value())\nprint(\"\"End times:\"\", end.value())\nprint(\"\"Tardiness:\"\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            },
            {
                "role": "user",
                "content": "Create job shop scheduling model with 5 jobs and 6 machines. All jobs have random routes and their operations have random durations. The due dates are calculated based on a total processing time of each job multiplied a due date allowance of 1.3. Release time of a job is a random value from 0 to 50. Jobs cannot start before their release times. Each job has a weight following a random distribution in which 20% will have weight of 1, 60% will have weight of 2, and 20% will have weight of 4. The objective function is total flow time (completion time - release time). Maximum duration is 20. After solving the problem, solutions will be printed and visualised. Note: Job two has to be completed first"
            },
            {
                "role": "assistant",
                "content": "# imports\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom cpmpy import *\nimport random\n# configurations\nrandom.seed(1)\nnumber_of_jobs = 5  \nnumber_of_machines = 6  \nmaximum_duration = 20\ndue_date_allowance = 1.3\nmaximum_release_time = 50\nweight_choices = [1, 2, 4]\nprobabilities = [0.2, 0.6, 0.2]\n# utility functions\ndef get_durations(number_of_jobs, number_of_machines, maximum_duration):\n    return np.array([[random.randint(1, maximum_duration) for _ in  range(number_of_machines)] for _ in range(number_of_jobs)])\n\ndef get_last_time(durations):\n    return sum(durations)\n\ndef get_task_to_machine_mapping(number_of_jobs, number_of_machines):\n    return np.array([random.sample(range(1, number_of_machines+1), number_of_machines) for _ in range(number_of_jobs)])\n\ndef get_jobs(number_of_jobs):\n    return [f\"\"Job Number{i+1}\"\" for i in range(number_of_jobs)]\n\ndef get_due_dates(due_date_allowance, durations):\n    return (0 + due_date_allowance*np.sum(durations, axis=1)).astype(int)\n\ndef get_release_times(number_of_jobs, maximum_release_time):\n    return [random.randint(0,maximum_release_time) for _ in range(number_of_jobs)]\n\ndef get_weights(weight_choices, probabilities, number_of_jobs):\n    return random.choices(weight_choices, weights=probabilities, k = number_of_jobs)\n# data preparation\ndurations = get_durations(number_of_jobs, number_of_machines, maximum_duration)\nlast_time = get_last_time(durations)\ndue_dates = get_due_dates(due_date_allowance, durations)\nrelease_times = get_release_times(number_of_jobs, maximum_release_time)\nweights = get_weights(weight_choices, probabilities, number_of_jobs)\ntask_to_machine_mapping = get_task_to_machine_mapping(number_of_jobs, number_of_machines)\njobs = get_jobs(number_of_jobs)\n# model\ndef model(last_time, task_to_machine_mapping):\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    # Decision variables\n    start = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"\"start\"\")  # Start time of each task\n    end = intvar(0, last_time, shape=(number_of_jobs, number_of_tasks), name=\"\"end\"\")  # End time of each task\n    tardiness = intvar(0, last_time, shape=(number_of_jobs), name=\"\"tardiness\"\")  # tardiness of each job\n\n    # model\n    m = Model()\n    return m, (start, end, tardiness)\n# constraints\ndef constraints(m, start, end, tardiness, durations, task_to_machine_mapping, due_dates, release_times):\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape\n    m + (start[:, 0] >= release_times)\n    m += (end == start + durations) # The end of every task is the sum of its start and duration\n\n    # No overlap on the same machine\n    for j in range(number_of_jobs): \n        for t in range(number_of_tasks):\n            m += [ (end[j, t] <= start[j2, t2]) | (end[j2, t2] <= start[j, t])\n                   for j2 in range(number_of_jobs) for t2 in range(number_of_tasks)\n                   if task_to_machine_mapping[j, t] == task_to_machine_mapping[j2, t2] and j != j2]\n\n    # Precedences: do tasks in order for all jobs\n    for t in range(number_of_tasks - 1):\n        m += [start[:, t + 1] >= end[:, t]]\n    \n    # calculate tardiness\n    for j in range(number_of_jobs):\n        m += (tardiness[j] == max([end[j, number_of_tasks -1] - due_dates[j], 0]))\n        \n    # Job two has to be completed first\n    for i in range(number_of_jobs):\n        if i != 1:\n            m += (end[i, 5] > end[1, 5])\n    return m\n# Objective\ndef objective(m, end, release_times, task_to_machine_mapping):\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape\n    m.minimize(sum(end[:, number_of_tasks -1] - release_times))\n\n    return m\n# visualization\ndef visualize(jobs, task_to_machine_mapping, start, end):\n    number_of_jobs, number_of_tasks = task_to_machine_mapping.shape  # jobs are rows, tasks are columns\n\n    job_names = np.repeat(jobs, number_of_tasks)\n    full_names = np.array([[f\"\"Task {j}_{t}\"\" for t in range(number_of_tasks)] for j in jobs])\n    df = pd.DataFrame({'Start': start.flatten(),\n                       'End': end.flatten(),\n                       'Machine': task_to_machine_mapping.flatten().astype(str),\n                       'Job': job_names.flatten(),\n                       'Name': full_names.flatten(),\n                       })\n    df['Time'] = df['End'] - df['Start']  # Length on x-axis\n\n    fig = px.bar(df, orientation='h',\n                 base=\"\"Start\"\", x=\"\"Time\"\", y=\"\"Machine\"\", color=\"\"Job\"\", text=\"\"Name\"\")\n    return fig.show()\n# define model\n(model, (start,end, tardiness)) = model(last_time, task_to_machine_mapping)\n\n#define constraints\nmodel = constraints(model, start, end, tardiness, durations, task_to_machine_mapping, due_dates, release_times)\n\n#define objective\nmodel = objective(model, end, release_times, task_to_machine_mapping)\n# solve\nsat = model.solve()\nif not sat: raise Exception(\"\"No solution found.\"\")\n    \n# output\nprint(\"\"Total Flowtime:\"\", sum(end[:, number_of_machines-1].value() - release_times))\nprint(\"\"Start times:\"\", start.value())\nprint(\"\"End times:\"\", end.value())\nprint(\"\"Tardiness:\"\", tardiness.value())\n\n# visualize\nvisualize(jobs, task_to_machine_mapping, start.value(), end.value())"
            }
        ]
    ]
}